# 埋点设计

## 为什么要做埋点，现有的埋点方案类型有哪些？

因为通过埋点数据可以分析出站点的使用情况以及热区，并且埋点数据也是做页面监控和性能监控的基础。

现有的埋点方案大致分为三种：

（1）代码埋点

代码埋点就是将所有的埋点逻辑都写在业务代码中，比如用户点击操作，在其绑定的 click 事件中增加调用埋点方法的逻辑触发，这种埋点方案会对业务代码造成很强的入侵性，并且随着项目的体积越来越庞大，页面数量越来越多，复杂度越来越高，这种埋点方案在后续维护和新老交接上都存在着很多问题，并且无法全局看到有哪些埋点信息。但是不可否认的是，在某些场景下，必须通过这种形式来进行埋点，这种埋点也有这其自身的优点，直观，并且影响小，只需要单独处理这一种场景即可，不用进行全局抽象处理，虽然改动起来比较麻烦，但改动影响点小，一对一的处理。

（2）可视化埋点

可视化埋点实际上是本质也是代码埋点，只不过手写代码的逻辑通过可视化交互的手段来完成，这种过程只是通过工具手段来提高代码埋点的效率，也存在着管理、维护、交接等问题，但是这种方式的优点在于，如果这个可视化工具做的足够优秀，那么就可以通过标识等将埋点快速找出，并有响应的解释描述，可以说是一种曲线救国的策略。

（3）无埋点

所谓的无埋点实际上是通过事件代理的方式，来记录埋点的，比如百度统计和友盟等，这种埋点方案通过事件，自动记录一些基本的数据信息，不会对业务代码造成入侵，一般情况下只需要引入一串 js 脚本代码即可，但是这种方式并不灵活，并且在一些复杂场景中，无法实现统计，比如跨页面关联等相关内容。虽然它减少了代码入侵，但同时也减少了适配的使用场景。但是这种方案更适合于性能监控或这页面监控这种需求，因为这些场景本就是业务场景之外的内容，本身不应该和业务逻辑相关联。

三种埋点方案实际上存在着相互补充的地方，在实际使用过程中需要根据具体场景来选择，同时这也取决于你对于埋点的关注数据是哪些数据有关。但是如果你自己要实现一套完整的性能监控+页面监控+埋点统计的工具，那么就需要提供这三方案的综合支持，对于特定的场景使用特定的方案来这行，对于场景进行分析处理，这个也是接下来要说的内容。

## 结合业务对埋点场景进行分析

从业务的角度考虑，实际上我们的埋点更多的是为了实现数据统计和数据分析，在业务上很多的关注点都是通过数据分析得出的，但是对应到具体的埋点位置可能就有多个了。下面就具体的业务场景进行分析。

1.  页面的 PV

页面的 PV 应该是所有的埋点场景中最基本的一种埋点场景，业务最基本的一种埋点诉求，主要是在打开页面的进行的一种埋点统计，在现有的前端框架体系中，对于单页应用，实际上就是路由变化时的埋点操作，对于非单页面的应用，则是在对应的 HTML 文件被访问的时候发出打点请求。对于这种埋点需求，完全可以通过无埋点的方案进行处理，当然也可以根据自己需要做一些特殊处理，这里说到的特殊处理包括有些场景下 url 参数的处理等逻辑，一般都可以通过自动化的手段进行处理。

2.  页面停留时长（这个可以通过堆栈的形式处理，页面路由跳转时，先出栈再入栈，出栈表示页面跳出，入栈表示页面访问，关闭的监听应该是要用 onbeforeunload）

页面停留时长数据实际上是用户对于产品使用情况的一种直观展现，一般来说用户的停留时长越长，说明对于站点内容的关注度是越高的，当然这也存在着一些异常场景，必须用户一直未关闭等，但是整体而言，数据还是存在参考意义的，现在的单页面的页面停留时长大部分实际上都是通过路由切换时对上一个路由做一个结束事件的打点计算，但是在实际的场景中，实际上会存在新开页签的方式打开页面，这种情况下实际上是无法有效统计到停留时长的，所以还需要对页签的关闭做监听处理。但是本质上这种业务场景中，也是可以通过自动化的方案进行处理的，而不需要对业务代码造成入侵。

3.  接口请求

接口请求的埋点实际上是将一些统计维度进行变化处理，例如需要统计一个成功生成链接的场景，这个链接的生成是通过接口的，那么这就涉及到在接口请求成功后的埋点，这种埋点场景，实际上就是将目标埋点分解，将很多真正的打点记录放到了接口返回后进行，这实际上就避免了在业务代码的判断逻辑中增添埋点逻辑，从而避免对业务代码的入侵。还有着另外一种场景，即涉及到推荐算法相关的内容，实际上在很多站点中，都存在这推荐的逻辑，例如 B 站、知乎、掘金等，这个时候实际上是需要记录每次推荐真正获取到的信息的，当然这些信息是需要服务端配合实现的。现在前端场景中用的最多的应该是 Axios，实际上是对 XMLHttpRequest 的一层封装，所以实际上可以通过覆写 XMLHttpRequest 的方法来实现。

4.  区域点击

区域点击的埋点也是较为普遍的一种埋点场景，这种场景实际上要考虑的东西也是很多的，对于复杂的业务场景而言，同样的一个按钮，可能是在不同的模块中调用的，那么这个按钮就被绑定上了模块属性，而且这种模块数据本质上是动态的，因为你的使用场景可能是非常多的，并且是无法预计的，如果都通过配置的形式去做，就会变的极其复杂与啰嗦，并且从可复用的角度考虑，也不会进行强绑定相关，所以这种埋点场景在有些情况下，实际上是无法做到真正和业务代码分离的，在行业内现有的埋点方案中，很多都是通过往 DOM 元素上绑定 data-[] 属性来处理的，这种点击会通过 body 上增加的监听器触发进行控制。实际上这里的区域点击也有点不准确，因为并非所有的场景都是按钮，有可能是一些热区等，在政采云之前做过的一个[分享](http://www.zyiz.net/tech/detail-135604.html)中实际上有对这种场景的明确描述，这个实际也是最容易对业务代码造成入侵的情况。

5.  展示即埋点

所谓的展示即埋点，实际上是对于一些 hover 或者弹窗场景而言的，因为有些内容的展示并不会直接展示，而是在某些特定操作后触发的，所以就有了这种展示即埋点的场景，从本质上来说，这是一种数据驱动的埋点场景（当然这里不考虑纯 css 实现的那种），对于这种场景，可能存在着两种实现逻辑，这两种实现逻辑对应了两种不同的展示逻辑，首先对于每次展示都是新渲染隐藏则销毁的场景而言，这种情况实际上在现有的框架中，在创建的声明周期中调用埋点或者通过监听响应式数据变化进行埋点两种方式，对于数据变化从而改变 css 样式的场景，只能通过响应式数据变化进行埋点处理。所以就通用性而言，监听响应式数据变化是一种更为通用的处理逻辑。这种展示即埋点的场景，无法避免的会造成业务代码入侵，也是一个需要认真考虑如何避免这种入侵的点。

6.  曝光埋点

曝光埋点实际取决于产品诉求，和产品规模，曝光埋点的原理实际上和图片懒加载的逻辑是一致的，都是到达可视区域后做一个判断操作，这个也会对业务代码造成入侵，因为这个会和 DOM 元素进行强关联，所有的监听实际上都是针对滚动区域中一直在增加的 DOM 元素而言的，这种强关联的逻辑，最好是提供一个通用的方法来处理，并且还可以共享埋点的全局配置。曝光埋点还有一种场景是对于类似热点问题推荐问题这些，这种展示不存在滚动加载的情况，基本上可以一屏展示下，所以这种曝光更适用于接口埋点

用户页面操作
页面跳转
网络请求
自定义事件
控制台输出

```javascript
function fun() {
	let i = 999;
	nAdd = () => {
		i++;
	};
	return () => {
		console.log(i);
	};
}
const getN = fun();
getN();
nAdd();
getN();
```

#### 下面这个例子需要注意一下

let 创建的变量的闭包中，作用域对象每次都是新生成的

let 在 for 循环中，实际上是将内部运行的函数包装成了匿名函数自调，所以相当于每次传了一个形参，

```javascript
function func() {
	arr = [];
	for (let i = 0; i < 3; i++) {
		arr[i] = function () {
			console.log(i);
		};
	}
}

func();
arr[0]();
arr[1]();
arr[2]();
```

### 函数柯里化

实现 add(1)(2)(3)可以运行，add(1,2)也可以运行

```javascript
function add(...arg) {
	let sum = 0;
	for (let i of arg) {
		sum += i;
	}
	let func = function (...props) {
		for (let i of arg) {
			sum += i;
		}
		return func;
	};

	func.toString = function () {
		return sum;
	};

	return func;
}
```

```javascript
function add(x1) {
	var sum = x1;
	var fun = function (x2) {
		sum += x2;
		return fun;
	};
	fun.toString = function () {
		console.log('toString');
		return sum;
	};

	fun.valueOf = function () {
		console.log('valueOf');
		return sum;
	};
	return fun;
}
```

### 用原生的 call()或 apply()模拟实现 bind()

```javascript
function jiSuan(base, bonus1, bonus2) {
	console.log(`${this.base}`);
}
```

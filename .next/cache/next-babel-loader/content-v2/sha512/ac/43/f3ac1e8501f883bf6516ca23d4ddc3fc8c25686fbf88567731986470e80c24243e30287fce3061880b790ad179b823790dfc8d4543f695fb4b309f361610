{"ast":null,"code":"'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _toArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toArray\"));\n\nvar _readOnlyError2 = _interopRequireDefault(require(\"@babel/runtime/helpers/readOnlyError\"));\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction unwrapExports(x) {\n  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nfunction createCommonjsModule(fn, module) {\n  return module = {\n    exports: {}\n  }, fn(module, module.exports), module.exports;\n}\n\nvar pathToRegexp_1 = createCommonjsModule(function (module, exports) {\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  }); // 词法分析类型\n\n  var tokensType = {\n    name: \"NAME\",\n    // 名称\n    \"char\": \"CHAR\",\n    // 字符\n    open: \"OPEN\",\n    // 开\n    close: \"CLOSE\",\n    // 关\n    escapedChar: \"ESCAPED_CHAR\",\n    // 分割符\n    modifier: \"MODIFIER\",\n    // 修饰符\n    pattern: \"PATTERN\",\n    // 范式 是用来描述name的\n    end: \"END\" // 结束\n\n  };\n  /**\r\n   * 拆分string\r\n   */\n\n  function escapeString(str) {\n    // 将非 ! : $ { } ( ) [ ] / \\ 的都按照转义字符处理,实际上看起来就是将通用的正则表达式中不是数据处理的数据全部剔除\n    return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n  }\n  /**\r\n   * 词法分析\r\n   * 实际上是分词,只不过这一步的分词主要是处理 范式(pattern) 和 字段名称(name) 这两种类型,其他的情况都简单处理,每个char都可以单独展示\r\n   * @param {Array} str\r\n   */\n\n\n  function lexer(str) {\n    var tokens = [];\n    var i = 0;\n    var strLength = str.length;\n\n    while (i < strLength) {\n      var _char = str[i]; // 处理修饰符\n\n      if (_char === \"*\" || _char === \"+\" || _char === \"?\") {\n        tokens.push({\n          type: tokensType.modifier,\n          index: i,\n          value: _char\n        });\n        i++;\n        continue;\n      } // 处理分割符\n\n\n      if (_char === \"\\\\\") {\n        // TODO 这里和源码实现不一样，源码中应该是将多过了一个字符串\n        tokens.push({\n          type: tokensType.escapedChar,\n          index: i,\n          value: _char\n        });\n        i++;\n        continue;\n      } // 处理开标签 {\n\n\n      if (_char === \"{\") {\n        tokens.push({\n          type: tokensType.open,\n          index: i,\n          value: _char\n        });\n        i++;\n        continue;\n      } // 处理闭标签 }\n\n\n      if (_char === \"}\") {\n        tokens.push({\n          type: tokensType.close,\n          index: i,\n          value: _char\n        });\n        i++;\n        continue;\n      } // 处理定义的随机类型name\n\n\n      if (_char === \":\") {\n        var name = \"\";\n        var j = i + 1; // 变量只能是0-9 a-z A-Z _(下滑线),这和很多的编程语言中变量的定义是一致的\n\n        while (j < strLength) {\n          var code = str.charCodeAt(j);\n\n          if ( // `0-9`\n          code >= 48 && code <= 57 || // `A-Z`\n          code >= 65 && code <= 90 || // `a-z`\n          code >= 97 && code <= 122 || // `_`\n          code === 95) {\n            name += str[j++];\n            continue;\n          }\n\n          break;\n        } // 如果名称不存在,则提示类型错误\n\n\n        if (!name) throw new TypeError(\"Missing parameter name at \".concat(i));\n        tokens.push({\n          type: tokensType.name,\n          index: i,\n          value: name\n        }); // 跨国中间的值,直接到name之后\n\n        i = j;\n        continue;\n      } // 处理pattern范式的情况\n\n\n      if (_char === \"(\") {\n        var _j = i + 1;\n\n        var pattern = \"\"; // 用来判断是否闭合\n\n        var count = 1;\n\n        if (str[_j] === \"?\") {\n          throw new SyntaxError(\"Pattern cannot start with \\\"?\\\" at \".concat(_j));\n        }\n\n        while (_j < strLength) {\n          var patternChar = str[_j]; // 如果是 \\ ,则添加两次,因为在比较的时候,字符串\\\\ 会被转义成 \\ 所以实际上一个\\对应两个字符,需要加两次\n\n          if (patternChar === \"\\\\\") {\n            pattern += str[_j++] + str[_j++];\n            continue;\n          }\n\n          if (patternChar === \")\") {\n            // 如果是)就闭合判断结束\n            count--;\n\n            if (count === 0) {\n              _j++;\n              break;\n            }\n          } else if (patternChar === \"(\") {\n            // 套娃\n            count++;\n\n            if (str[_j + 1] !== \"?\") {\n              throw new TypeError(\"Capturing groups are not allowed at \".concat(_j));\n            }\n          }\n\n          pattern += str[_j++];\n        } // count 存在说明没有完全闭合或者闭合过多了\n\n\n        if (count) throw new TypeError(\"Unbalanced pattern at \".concat(i));\n        if (!pattern) throw new TypeError(\"Missing pattern at \".concat(i));\n        tokens.push({\n          type: tokensType.pattern,\n          index: i,\n          value: pattern\n        });\n        i = _j;\n        continue;\n      } // 不是以上各种情况,就全部认为是 字符 (char)\n\n\n      tokens.push({\n        type: tokensType[\"char\"],\n        index: i,\n        value: str[i++]\n      });\n    }\n\n    tokens.push({\n      type: tokensType.end,\n      index: i,\n      value: \"\"\n    });\n    return tokens;\n  }\n  /**\r\n   * 根据词法分析结果 分词 ,或者说是生成一个标准化的数组,用于后续连续性处理\r\n   * 返回字符串或者 词法对象\r\n   * 词法对象结构\r\n   * {\r\n   *      modifier:'', // 修饰符\r\n          name:'test', // 名称\r\n          pattern:'[^\\\\/#\\\\?]+?', // 范式（用于实际匹配）\r\n          prefix:'/', // 前缀\r\n          suffix:'', // 后缀\r\n   * }\r\n   */\n  // TODO 后续可以考虑将分词器和格式化的统一整合，直接输出分词结果\n\n\n  function parse(str) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var tokens = lexer(str);\n    var _options$prefixes = options.prefixes,\n        prefixes = _options$prefixes === void 0 ? \"./\" : _options$prefixes; // defaultPattern 应该是一个特性的范式,用来匹配任意值即可,实际上用排除法,在路由的判断里,不能算在路由中的实际上只有 /(pathname) #(hash) ?(search)\n\n    var defaultPattern = \"[^\".concat(escapeString(options.delimiter || \"/#?\"), \"]+?\");\n    var i = 0;\n    var tokensLength = tokens.length;\n    var result = [];\n    var path = \"\";\n    var key = 0;\n    /**\r\n     * 尝试获取指定类型的值,不存在则返回null\r\n     */\n\n    var tryConsume = function tryConsume(type) {\n      var result = null;\n\n      if (i < tokensLength && tokens[i].type === type) {\n        result = tokens[i].value;\n        i++;\n      }\n\n      return result;\n    };\n    /**\r\n     * 必须获取指定值,如果不是指定值则报错\r\n     */\n\n\n    var mustConsume = function mustConsume(type) {\n      var value = tryConsume(type); // 满足期望,则返回值\n\n      if (value !== undefined) {\n        return value;\n      } // 不满足期望则提示\n\n\n      var _tokens$i = tokens[i],\n          nextType = _tokens$i.type,\n          index = _tokens$i.index;\n      throw new TypeError(\"Unexpected \".concat(nextType, \" at \").concat(index, \", expected \").concat(type));\n    };\n    /**\r\n     * 获取固定的前缀\r\n     */\n\n\n    var consumeText = function consumeText() {\n      var result = \"\";\n      var value;\n\n      while (value = tryConsume(tokensType[\"char\"]) || tryConsume(tokensType.escapedChar)) {\n        result += value;\n      }\n\n      return result;\n    };\n\n    while (i < tokensLength) {\n      // 获取char\n      var _char2 = tryConsume(tokensType[\"char\"]); // 获取name 和 pattern\n\n\n      var name = tryConsume(tokensType.name);\n      var pattern = tryConsume(tokensType.pattern); // name 或者 pattern 存在说明了存在匹配类型,从本质上看,这两种情况的处理逻辑是一致的,都是设置name值,然后设置范式\n\n      if (name || pattern) {\n        // 前缀默认为char的值\n        var prefix = _char2 || \"\";\n        /**\r\n         * 如果前缀不存在,则表明char是path的一部分,如果前缀存在则直接作为前缀使用即可,还存在一种特殊的场景,就是固定的值后又匹配了对应的数据,是一个动态的路由\r\n         * 举一个例子,动态路由的前缀都是/detail + 对应详情id的形式,用于的场景可能是埋点等,暂时考虑不到实际的使用用途,但是应该有存在的可能性\r\n         */\n\n        if (prefixes.indexOf(prefix) === -1) {\n          path += prefix;\n          prefix = ((0, _readOnlyError2[\"default\"])(\"prefix\"), \"\");\n        }\n        /**\r\n         * 如果path存在就直接设置了path,因为对于path存在的场景,数据是固定了路由的,所以范式和配置的其他条件都是没有用的\r\n         * 没有前缀的时候,实际上说明上一个数据是一个的固定值,这就可能是一个动态路由的场景\r\n         */\n\n\n        if (path) {\n          result.push(path);\n          path = \"\";\n        } // 需要按照动态参数的匹配场景处理,有name就使用name,没有就默认key值即可,对于一个url而言,实际上基本key不会太多,修饰符标识1个多个的关系,就是正则表达式中的+ ? *\n\n\n        result.push({\n          name: name || key++,\n          prefix: prefix,\n          suffix: \"\",\n          pattern: pattern || defaultPattern,\n          modifier: tryConsume(tokensType.modifier) || \"\"\n        });\n        continue;\n      } // 分割符当作是路由的一部分,可能属于一种奇怪的路由形式,其他情况就是不断的拼接char,知道无法拼接完成(本质上是将之前拆分的分词组合起来)\n\n\n      var value = _char2 || tryConsume(tokensType.escapedChar);\n\n      if (value) {\n        path += value;\n        continue;\n      } // 如果path存在就直接填充\n\n\n      if (path) {\n        result.push(path);\n        path = \"\";\n        continue;\n      }\n\n      var open = tryConsume(tokensType.open);\n\n      if (open) {\n        /**\r\n         * open中的内容实际上也只包含三种类型,首先前面char类型的,一开始获取到的char类型的实际上都是前缀,因为这部分是不变的\r\n         * 然后获取到的类型为 name 和 pattern 两种,  最后的char类型按照后缀来\r\n         * 但是必须要open close 组合结尾,不能多个open,这种情况不做处理\r\n         */\n        var _prefix = consumeText();\n\n        var _name = tryConsume(tokensType.name) || \"\";\n\n        var _pattern = tryConsume(tokensType.pattern) || \"\";\n\n        var suffix = consumeText();\n        mustConsume(tokensType.close); // 插入判断类型,name只有在存在 name 或者 pattern 的时候才是有价值的，否则实际上就是一个固定值\n\n        result.push({\n          name: _name || (_pattern ? key++ : \"\"),\n          prefix: _prefix,\n          suffix: suffix,\n          pattern: _name && !_pattern ? defaultPattern : _pattern,\n          modifier: tryConsume(tokensType.modifier) || \"\"\n        });\n        continue;\n      } // 当所有的情况都不匹配的时候,必须是end结尾\n\n\n      mustConsume(tokensType.end);\n    }\n\n    return result;\n  }\n  /**\r\n   * 判断是否区分大小写\r\n   */\n\n\n  function flags(options) {\n    return options && options.sensitive ? \"\" : \"i\";\n  }\n  /**\r\n   * 将分词处理过的数据,转换成正则表达式\r\n   */\n\n\n  function tokensToRegexp(tokens, keys, options) {\n    var _options$strict = options.strict,\n        strict = _options$strict === void 0 ? false : _options$strict,\n        _options$start = options.start,\n        start = _options$start === void 0 ? true : _options$start,\n        _options$end = options.end,\n        end = _options$end === void 0 ? true : _options$end,\n        _options$encode = options.encode,\n        encode = _options$encode === void 0 ? function (x) {\n      return x;\n    } : _options$encode; // 设置的结尾字符转义化处理\n\n    var endsWith = \"[\".concat(escapeString(options.endsWith || \"\"), \"]|$\"); // 匹配的最后一个词的转义化处理\n\n    var delimiter = \"[\".concat(escapeString(options.delimiter || \"/#?\"), \"]\");\n    var route = start ? \"^\" : \"\"; // 遍历分词数组\n\n    var _iterator = _createForOfIteratorHelper(tokens),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var token = _step.value; // 如果是字符串就直接拼接到route中\n\n        if (typeof token === \"string\") {\n          route += escapeString(encode(token));\n        } else {\n          // 分词对象的时候，先处理前后缀的正则\n          var prefix = escapeString(encode(token.prefix));\n          var suffix = escapeString(encode(token.suffix)); // 如果存在范式\n\n          if (token.pattern) {\n            // 设置在keys中主要是为了后续处理url中params数据\n            if (keys) {\n              keys.push(token);\n            }\n\n            if (prefix || suffix) {\n              if (token.modifier === \"+\" || token.modifier === \"*\") {\n                // 将 + 和 * 单独处理了，即手动的设置一个存在的，然后再设置一个* 的，然后整体为 ?\n                var mod = token.modifier === \"*\" ? \"?\" : \"\";\n                route += \"(?:\".concat(prefix, \"((?:\").concat(token.pattern, \")(?:\").concat(suffix).concat(prefix, \"(?:\").concat(token.pattern, \"))*)\").concat(suffix, \")\").concat(mod);\n              } else {\n                route += \"(?:\".concat(prefix, \"(\").concat(token.pattern, \")\").concat(suffix, \")\").concat(token.modifier);\n              }\n            } else {\n              // 没有前后缀就直接设置正则即可\n              route += \"(\".concat(token.pattern, \")\").concat(token.modifier);\n            }\n          } else {\n            // TODO 没有范式，说明是??? ,没考虑清楚\n            route += \"(?:\".concat(prefix).concat(suffix, \")\").concat(token.modifier);\n          }\n        }\n      } // 是否字符串的结尾匹配\n\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    if (end) {\n      // 允许尾部分割符处理\n      if (!strict) {\n        route += \"\".concat(delimiter, \"?\");\n      } // 是否设置结束字符，如果没有则默认为$ 否则指定固定值\n\n\n      route += !options.endsWith ? \"$\" : \"(?=\".concat(endsWith, \")\");\n    } else {\n      // 如果最后以是字符串，则判断是否是尾部分割符\n      var endToken = tokens[tokens.length - 1];\n      var isEndDelimited = typeof endToken === \"string\" ? delimiter.indexOf(endToken[endToken.length - 1]) > -1 : // tslint:disable-next-line\n      endToken === undefined; // 允许尾部分割符处理\n\n      if (!strict) {\n        route += \"(?:\".concat(delimiter, \"(?=\").concat(endsWith, \"))?\");\n      } // 最后一个不是结束分割符的时候，手动添加\n\n\n      if (!isEndDelimited) {\n        route += \"(?=\".concat(delimiter, \"|\").concat(endsWith, \")\");\n      }\n    }\n\n    return new RegExp(route, flags(options));\n  }\n  /**\r\n   * 字符串处理\r\n   */\n\n\n  function stringToRegexp(path, keys, options) {\n    return tokensToRegexp(parse(path, options), keys, options);\n  }\n  /**\r\n   * 正则转正则\r\n   */\n\n\n  function regexpToRegexp(path, keys) {\n    // 正则的处理如果没有keys的，直接返回即可\n    if (!keys) return path; // TODO 只明白了要将 没懂  \\( 开头   (?:\\?<(.*?)>) 非获取匹配?<任意值> 的数据    (.*?) 任意字符存在0个或1个，并获取      (?!\\?) 为非?\n\n    var groupsRegexp = /\\((?:\\?<(.*?)>)?(?!\\?)/g;\n    var index = 0;\n    var execResult = groupsRegexp.exec(path.source);\n\n    while (execResult) {\n      keys.push({\n        // Use parenthesized substring match if available, index otherwise\n        name: execResult[1] || index++,\n        prefix: \"\",\n        suffix: \"\",\n        modifier: \"\",\n        pattern: \"\"\n      });\n      execResult = groupsRegex.exec(path.source);\n    }\n\n    return path;\n  }\n  /**\r\n   * 数组转正则\r\n   */\n\n\n  function arrayToRegexp(paths, keys, options) {\n    // 循环调用paths，每个单独处理，然后生成一个| 的匹配形式的正则\n    var parts = paths.map(function (path) {\n      return pathToRegexp(path, keys, options).source;\n    });\n    return new RegExp(\"(?:\".concat(parts.join(\"|\"), \")\"), flags(options));\n  }\n  /**\r\n   *\r\n   * @param {String|Array|RegExp} path\r\n   * @param {Array} keys\r\n   * @param {Object} options\r\n   */\n\n\n  function pathToRegexp(path, keys, options) {\n    // TODO 数组和正则的都不太了解使用场景\n    if (path instanceof RegExp) return regexpToRegexp(path, keys);\n    if (Array.isArray(path)) return arrayToRegexp(path, keys, options);\n    return stringToRegexp(path, keys, options);\n  }\n\n  exports.pathToRegexp = pathToRegexp;\n});\nunwrapExports(pathToRegexp_1);\nvar pathToRegexp_2 = pathToRegexp_1.pathToRegexp;\n/**\r\n * 缓存判断过的数据\r\n */\n\nvar cache = {};\nvar cachePathList = [];\nvar cacheLimit = 10000;\nvar cacheCount = 0;\n/**\r\n * 比较判断path\r\n * @param {*} path\r\n * @param {*} options\r\n */\n\nfunction compilePath(path) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (cache[path]) {\n    return cache[path];\n  }\n\n  var keys = [];\n  var regexp = pathToRegexp_2(path, keys, options);\n  var result = {\n    regexp: regexp,\n    keys: keys\n  };\n\n  if (cacheCount < cacheLimit) {\n    cache[path] = result;\n    cachePathList.push(path);\n    cacheCount++;\n  } else {\n    // 这里采用操作系统的缓存算法，考虑到整体的复杂度，感觉还是使用先进先出算法(FIFO)容易一点，可以考虑其他缓存算法\n    var removePath = cachePathList.shift();\n    delete cache[removePath];\n    cache[path] = result;\n    cachePathList.push(path);\n  }\n\n  return result;\n}\n/**\r\n * 判断是否符合路由条件\r\n * @param {*} path\r\n * @param {*} target\r\n */\n\n\nfunction matchPath(locationPath) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (typeof options === \"string\" || Array.isArray(options)) {\n    options = {\n      path: options\n    };\n  }\n\n  var _options = options,\n      path = _options.path,\n      _options$exact = _options.exact,\n      exact = _options$exact === void 0 ? false : _options$exact,\n      _options$strict2 = _options.strict,\n      strict = _options$strict2 === void 0 ? false : _options$strict2,\n      _options$sensitive = _options.sensitive,\n      sensitive = _options$sensitive === void 0 ? false : _options$sensitive; // 避免options 是 数组的情况\n\n  var paths = [].concat(path); // 只处理数组的第一个，其他\n\n  return paths.reduce(function (matched, path) {\n    if (!path && path !== \"\") return null;\n    if (matched) return matched;\n    var options = {\n      end: exact,\n      strict: strict,\n      sensitive: sensitive\n    }; // 生成path的正则表达式\n\n    var _compilePath = compilePath(path, options),\n        regexp = _compilePath.regexp,\n        keys = _compilePath.keys; // 判断是否匹配路由哦\n\n\n    var match = regexp.exec(locationPath);\n    if (!match) return null; // 第一个值是匹配到的url内容，后面的对应:test 这种动态路由的值\n\n    var _match = (0, _toArray2[\"default\"])(match),\n        url = _match[0],\n        values = _match.slice(1);\n\n    var isExact = locationPath === url; // 不匹配的时候返回null\n\n    if (exact && !isExact) return null; // TODO 这里需要考虑一个问题，如果存在两个都能匹配到的路由的时候，优先级是怎么样的\n\n    return {\n      path: path,\n      // the path used to match\n      url: path === \"/\" && url === \"\" ? \"/\" : url,\n      // the matched portion of the URL\n      isExact: isExact,\n      // whether or not we matched exactly\n      params: keys.reduce(function (memo, key, index) {\n        // 生成params对象\n        memo[key.name] = values[index];\n        return memo;\n      }, {})\n    };\n  }, null);\n}\n\nexports.compilePath = compilePath;\nexports.matchPath = matchPath;","map":{"version":3,"sources":["D:/self/develop/selfComponents/src/utils/router-match.js"],"names":["Object","value","x","exports","fn","module","pathToRegexp_1","createCommonjsModule","tokensType","name","open","close","escapedChar","modifier","pattern","end","str","tokens","i","strLength","char","type","index","j","code","count","patternChar","options","lexer","prefixes","defaultPattern","escapeString","tokensLength","result","path","key","tryConsume","mustConsume","nextType","consumeText","prefix","suffix","strict","start","encode","endsWith","delimiter","route","token","keys","mod","endToken","isEndDelimited","flags","tokensToRegexp","parse","groupsRegexp","execResult","groupsRegex","parts","pathToRegexp","regexpToRegexp","Array","arrayToRegexp","stringToRegexp","unwrapExports","pathToRegexp_2","cache","cachePathList","cacheLimit","cacheCount","regexp","removePath","exact","sensitive","paths","compilePath","match","url","values","isExact","locationPath","params","memo"],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEAA,MAAM,CAANA,cAAAA,CAAAA,OAAAA,EAAAA,YAAAA,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7CD;;AAEA,SAAA,aAAA,CAAA,CAAA,EAA2B;AAC1B,SAAOE,CAAC,IAAIA,CAAC,CAANA,UAAAA,IAAqBF,MAAM,CAANA,SAAAA,CAAAA,cAAAA,CAAAA,IAAAA,CAAAA,CAAAA,EAArBE,SAAqBF,CAArBE,GAA0EA,CAAC,CAA3EA,SAA2E,CAA3EA,GAAP,CAAA;AACA;;AAED,SAAA,oBAAA,CAAA,EAAA,EAAA,MAAA,EAA0C;AACzC,SAAO,MAAM,GAAG;AAAEC,IAAAA,OAAO,EAAE;AAAX,GAAT,EAA0BC,EAAE,CAAA,MAAA,EAASC,MAAM,CAA3C,OAA4B,CAA5B,EAAsDA,MAAM,CAAnE,OAAA;AACA;;AAED,IAAIC,cAAc,GAAGC,oBAAoB,CAAC,UAAA,MAAA,EAAA,OAAA,EAA2B;AAErEP,EAAAA,MAAM,CAANA,cAAAA,CAAAA,OAAAA,EAAAA,YAAAA,EAA6C;AAAEC,IAAAA,KAAK,EAAE;AAAT,GAA7CD,EAFqE,CAIrE;;AACA,MAAMQ,UAAU,GAAG;AACjBC,IAAAA,IAAI,EADa,MAAA;AACH;AACd,YAFiB,MAAA;AAEH;AACdC,IAAAA,IAAI,EAHa,MAAA;AAGH;AACdC,IAAAA,KAAK,EAJY,OAAA;AAID;AAChBC,IAAAA,WAAW,EALM,cAAA;AAKY;AAC7BC,IAAAA,QAAQ,EANS,UAAA;AAMK;AACtBC,IAAAA,OAAO,EAPU,SAAA;AAOG;AACpBC,IAAAA,GAAG,EARc,KAAA,CAQL;;AARK,GAAnB;AAWA;AACA;AACA;;AACA,WAAA,YAAA,CAAA,GAAA,EAA2B;AACzB;AACA,WAAOC,GAAG,CAAHA,OAAAA,CAAAA,2BAAAA,EAAP,MAAOA,CAAP;AACD;AAED;AACA;AACA;AACA;AACA;;;AACA,WAAA,KAAA,CAAA,GAAA,EAAoB;AAClB,QAAIC,MAAM,GAAV,EAAA;AACA,QAAIC,CAAC,GAAL,CAAA;AACA,QAAMC,SAAS,GAAGH,GAAG,CAArB,MAAA;;AACA,WAAOE,CAAC,GAAR,SAAA,EAAsB;AACpB,UAAME,KAAI,GAAGJ,GAAG,CADI,CACJ,CAAhB,CADoB,CAGpB;;AACA,UAAII,KAAI,KAAJA,GAAAA,IAAgBA,KAAI,KAApBA,GAAAA,IAAgCA,KAAI,KAAxC,GAAA,EAAkD;AAChDH,QAAAA,MAAM,CAANA,IAAAA,CAAY;AAAEI,UAAAA,IAAI,EAAEb,UAAU,CAAlB,QAAA;AAA6Bc,UAAAA,KAAK,EAAlC,CAAA;AAAuCrB,UAAAA,KAAK,EAAEmB;AAA9C,SAAZH;AACAC,QAAAA,CAAC;AACD;AAPkB,OAAA,CASpB;;;AACA,UAAIE,KAAI,KAAR,IAAA,EAAmB;AACjB;AACAH,QAAAA,MAAM,CAANA,IAAAA,CAAY;AAAEI,UAAAA,IAAI,EAAEb,UAAU,CAAlB,WAAA;AAAgCc,UAAAA,KAAK,EAArC,CAAA;AAA0CrB,UAAAA,KAAK,EAAEmB;AAAjD,SAAZH;AACAC,QAAAA,CAAC;AACD;AAdkB,OAAA,CAgBpB;;;AACA,UAAIE,KAAI,KAAR,GAAA,EAAkB;AAChBH,QAAAA,MAAM,CAANA,IAAAA,CAAY;AAAEI,UAAAA,IAAI,EAAEb,UAAU,CAAlB,IAAA;AAAyBc,UAAAA,KAAK,EAA9B,CAAA;AAAmCrB,UAAAA,KAAK,EAAEmB;AAA1C,SAAZH;AACAC,QAAAA,CAAC;AACD;AApBkB,OAAA,CAsBpB;;;AACA,UAAIE,KAAI,KAAR,GAAA,EAAkB;AAChBH,QAAAA,MAAM,CAANA,IAAAA,CAAY;AAAEI,UAAAA,IAAI,EAAEb,UAAU,CAAlB,KAAA;AAA0Bc,UAAAA,KAAK,EAA/B,CAAA;AAAoCrB,UAAAA,KAAK,EAAEmB;AAA3C,SAAZH;AACAC,QAAAA,CAAC;AACD;AA1BkB,OAAA,CA6BpB;;;AACA,UAAIE,KAAI,KAAR,GAAA,EAAkB;AAChB,YAAIX,IAAI,GAAR,EAAA;AACA,YAAIc,CAAC,GAAGL,CAAC,GAFO,CAEhB,CAFgB,CAGhB;;AACA,eAAOK,CAAC,GAAR,SAAA,EAAsB;AACpB,cAAMC,IAAI,GAAGR,GAAG,CAAHA,UAAAA,CAAb,CAAaA,CAAb;;AAEA,eACE;AACCQ,UAAAA,IAAI,IAAJA,EAAAA,IAAcA,IAAI,IAAnB,EAACA,IACD;AACCA,UAAAA,IAAI,IAAJA,EAAAA,IAAcA,IAAI,IAFnB,EAACA,IAGD;AACCA,UAAAA,IAAI,IAAJA,EAAAA,IAAcA,IAAI,IAJnB,GAACA,IAKD;AACAA,UAAAA,IAAI,KARN,EAAA,EASE;AACAf,YAAAA,IAAI,IAAIO,GAAG,CAACO,CAAZd,EAAW,CAAXA;AACA;AACD;;AAED;AArBc,SAAA,CAuBhB;;;AACA,YAAI,CAAJ,IAAA,EAAW,MAAM,IAAA,SAAA,CAAA,6BAAA,MAAA,CAAN,CAAM,CAAA,CAAN;AACXQ,QAAAA,MAAM,CAANA,IAAAA,CAAY;AAAEI,UAAAA,IAAI,EAAEb,UAAU,CAAlB,IAAA;AAAyBc,UAAAA,KAAK,EAA9B,CAAA;AAAmCrB,UAAAA,KAAK,EAAEQ;AAA1C,SAAZQ,EAzBgB,CA0BhB;;AACAC,QAAAA,CAAC,GAADA,CAAAA;AACA;AA1DkB,OAAA,CA6DpB;;;AACA,UAAIE,KAAI,KAAR,GAAA,EAAkB;AAChB,YAAIG,EAAC,GAAGL,CAAC,GAAT,CAAA;;AACA,YAAIJ,OAAO,GAFK,EAEhB,CAFgB,CAGhB;;AACA,YAAIW,KAAK,GAAT,CAAA;;AAEA,YAAIT,GAAG,CAAHA,EAAG,CAAHA,KAAJ,GAAA,EAAoB;AAClB,gBAAM,IAAA,WAAA,CAAA,sCAAA,MAAA,CAAN,EAAM,CAAA,CAAN;AACD;;AAED,eAAOO,EAAC,GAAR,SAAA,EAAsB;AACpB,cAAMG,WAAW,GAAGV,GAAG,CADH,EACG,CAAvB,CADoB,CAEpB;;AACA,cAAIU,WAAW,KAAf,IAAA,EAA0B;AACxBZ,YAAAA,OAAO,IAAIE,GAAG,CAACO,EAAJP,EAAG,CAAHA,GAAWA,GAAG,CAACO,EAA1BT,EAAyB,CAAzBA;AACA;AACD;;AAED,cAAIY,WAAW,KAAf,GAAA,EAAyB;AACvB;AACAD,YAAAA,KAAK;;AACL,gBAAIA,KAAK,KAAT,CAAA,EAAiB;AACfF,cAAAA,EAAC;AACD;AACD;AANH,WAAA,MAOO,IAAIG,WAAW,KAAf,GAAA,EAAyB;AAC9B;AACAD,YAAAA,KAAK;;AACL,gBAAIT,GAAG,CAACO,EAAC,GAALP,CAAG,CAAHA,KAAJ,GAAA,EAAwB;AACtB,oBAAM,IAAA,SAAA,CAAA,uCAAA,MAAA,CAAN,EAAM,CAAA,CAAN;AACD;AACF;;AAEDF,UAAAA,OAAO,IAAIE,GAAG,CAACO,EAAfT,EAAc,CAAdA;AAjCc,SAAA,CAmChB;;;AACA,YAAA,KAAA,EAAW,MAAM,IAAA,SAAA,CAAA,yBAAA,MAAA,CAAN,CAAM,CAAA,CAAN;AACX,YAAI,CAAJ,OAAA,EAAc,MAAM,IAAA,SAAA,CAAA,sBAAA,MAAA,CAAN,CAAM,CAAA,CAAN;AAEdG,QAAAA,MAAM,CAANA,IAAAA,CAAY;AAAEI,UAAAA,IAAI,EAAEb,UAAU,CAAlB,OAAA;AAA4Bc,UAAAA,KAAK,EAAjC,CAAA;AAAsCrB,UAAAA,KAAK,EAAEa;AAA7C,SAAZG;AACAC,QAAAA,CAAC,GAADA,EAAAA;AACA;AAvGkB,OAAA,CA0GpB;;;AACAD,MAAAA,MAAM,CAANA,IAAAA,CAAY;AAAEI,QAAAA,IAAI,EAAEb,UAAU,CAAlB,MAAkB,CAAlB;AAAyBc,QAAAA,KAAK,EAA9B,CAAA;AAAmCrB,QAAAA,KAAK,EAAEe,GAAG,CAACE,CAAD,EAAA;AAA7C,OAAZD;AACD;;AACDA,IAAAA,MAAM,CAANA,IAAAA,CAAY;AAAEI,MAAAA,IAAI,EAAEb,UAAU,CAAlB,GAAA;AAAwBc,MAAAA,KAAK,EAA7B,CAAA;AAAkCrB,MAAAA,KAAK,EAAE;AAAzC,KAAZgB;AACA,WAAA,MAAA;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,WAAA,KAAA,CAAA,GAAA,EAAkC;AAAA,QAAdU,OAAc,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAJ,EAAI;AAChC,QAAMV,MAAM,GAAGW,KAAK,CAApB,GAAoB,CAApB;AADgC,QAAA,iBAAA,GAEJD,OAFI,CAAA,QAAA;AAAA,QAExBE,QAFwB,GAAA,iBAAA,KAAA,KAAA,CAAA,GAAA,IAAA,GAAA,iBAAA,CAAA,CAGhC;;AACA,QAAMC,cAAc,GAAA,KAAA,MAAA,CAAQC,YAAY,CAACJ,OAAO,CAAPA,SAAAA,IAArB,KAAoB,CAApB,EAApB,KAAoB,CAApB;AACA,QAAIT,CAAC,GAAL,CAAA;AACA,QAAMc,YAAY,GAAGf,MAAM,CAA3B,MAAA;AACA,QAAIgB,MAAM,GAAV,EAAA;AACA,QAAIC,IAAI,GAAR,EAAA;AACA,QAAIC,GAAG,GAAP,CAAA;AAEA;AACF;AACA;;AACE,QAAMC,UAAU,GAAG,SAAbA,UAAa,CAAA,IAAA,EAAU;AAC3B,UAAIH,MAAM,GAAV,IAAA;;AACA,UAAIf,CAAC,GAADA,YAAAA,IAAoBD,MAAM,CAANA,CAAM,CAANA,CAAAA,IAAAA,KAAxB,IAAA,EAAiD;AAC/CgB,QAAAA,MAAM,GAAGhB,MAAM,CAANA,CAAM,CAANA,CAATgB,KAAAA;AACAf,QAAAA,CAAC;AACF;;AACD,aAAA,MAAA;AANF,KAAA;AASA;AACF;AACA;;;AACE,QAAImB,WAAW,GAAG,SAAdA,WAAc,CAAA,IAAA,EAAgB;AAChC,UAAMpC,KAAK,GAAGmC,UAAU,CADQ,IACR,CAAxB,CADgC,CAEhC;;AACA,UAAInC,KAAK,KAAT,SAAA,EAAyB;AACvB,eAAA,KAAA;AAJ8B,OAAA,CAMhC;;;AANgC,UAAA,SAAA,GAOEgB,MAAM,CAPR,CAOQ,CAPR;AAAA,UAOlBqB,QAPkB,GAAA,SAAA,CAAA,IAAA;AAAA,UAORhB,KAPQ,GAAA,SAAA,CAAA,KAAA;AAQhC,YAAM,IAAA,SAAA,CAAA,cAAA,MAAA,CAAA,QAAA,EAAA,MAAA,EAAA,MAAA,CAAA,KAAA,EAAA,aAAA,EAAA,MAAA,CAAN,IAAM,CAAA,CAAN;AARF,KAAA;AAUA;AACF;AACA;;;AACE,QAAIiB,WAAW,GAAG,SAAdA,WAAc,GAAY;AAC5B,UAAIN,MAAM,GAAV,EAAA;AACA,UAAA,KAAA;;AACA,aACGhC,KAAK,GACJmC,UAAU,CAAC5B,UAAU,CAArB4B,MAAqB,CAAX,CAAVA,IAA+BA,UAAU,CAAC5B,UAAU,CAFxD,WAE6C,CAF7C,EAGE;AACAyB,QAAAA,MAAM,IAANA,KAAAA;AACD;;AACD,aAAA,MAAA;AATF,KAAA;;AAYA,WAAOf,CAAC,GAAR,YAAA,EAAyB;AACvB;AACA,UAAME,MAAI,GAAGgB,UAAU,CAAC5B,UAAU,CAFX,MAEW,CAAX,CAAvB,CAFuB,CAGvB;;;AACA,UAAMC,IAAI,GAAG2B,UAAU,CAAC5B,UAAU,CAAlC,IAAuB,CAAvB;AACA,UAAMM,OAAO,GAAGsB,UAAU,CAAC5B,UAAU,CALd,OAKG,CAA1B,CALuB,CAMvB;;AACA,UAAIC,IAAI,IAAR,OAAA,EAAqB;AACnB;AACA,YAAM+B,MAAM,GAAGpB,MAAI,IAAnB,EAAA;AACA;AACN;AACA;AACA;;AACM,YAAIS,QAAQ,CAARA,OAAAA,CAAAA,MAAAA,MAA6B,CAAjC,CAAA,EAAqC;AACnCK,UAAAA,IAAI,IAAJA,MAAAA;AACAM,UAAAA,MAAM,IAAA,gCAAA,QAAA,GAANA,EAAM,CAANA;AACD;AACD;AACN;AACA;AACA;;;AACM,YAAA,IAAA,EAAU;AACRP,UAAAA,MAAM,CAANA,IAAAA,CAAAA,IAAAA;AACAC,UAAAA,IAAI,GAAJA,EAAAA;AAjBiB,SAAA,CAmBnB;;;AACAD,QAAAA,MAAM,CAANA,IAAAA,CAAY;AACVxB,UAAAA,IAAI,EAAEA,IAAI,IAAI0B,GADJ,EAAA;AAEVK,UAAAA,MAAM,EAFI,MAAA;AAGVC,UAAAA,MAAM,EAHI,EAAA;AAIV3B,UAAAA,OAAO,EAAEA,OAAO,IAJN,cAAA;AAKVD,UAAAA,QAAQ,EAAEuB,UAAU,CAAC5B,UAAU,CAArB4B,QAAU,CAAVA,IAAmC;AALnC,SAAZH;AAOA;AAlCqB,OAAA,CAqCvB;;;AACA,UAAMhC,KAAK,GAAGmB,MAAI,IAAIgB,UAAU,CAAC5B,UAAU,CAA3C,WAAgC,CAAhC;;AACA,UAAA,KAAA,EAAW;AACT0B,QAAAA,IAAI,IAAJA,KAAAA;AACA;AAzCqB,OAAA,CA4CvB;;;AACA,UAAA,IAAA,EAAU;AACRD,QAAAA,MAAM,CAANA,IAAAA,CAAAA,IAAAA;AACAC,QAAAA,IAAI,GAAJA,EAAAA;AACA;AACD;;AAED,UAAMxB,IAAI,GAAG0B,UAAU,CAAC5B,UAAU,CAAlC,IAAuB,CAAvB;;AACA,UAAA,IAAA,EAAU;AACR;AACN;AACA;AACA;AACA;AACM,YAAMgC,OAAM,GAAGD,WAAf,EAAA;;AACA,YAAM9B,KAAI,GAAG2B,UAAU,CAAC5B,UAAU,CAArB4B,IAAU,CAAVA,IAAb,EAAA;;AACA,YAAMtB,QAAO,GAAGsB,UAAU,CAAC5B,UAAU,CAArB4B,OAAU,CAAVA,IAAhB,EAAA;;AACA,YAAMK,MAAM,GAAGF,WAAf,EAAA;AACAF,QAAAA,WAAW,CAAC7B,UAAU,CAVd,KAUG,CAAX6B,CAVQ,CAWR;;AACAJ,QAAAA,MAAM,CAANA,IAAAA,CAAY;AACVxB,UAAAA,IAAI,EAAEA,KAAI,KAAKK,QAAO,GAAGqB,GAAH,EAAA,GADZ,EACA,CADA;AAEVK,UAAAA,MAAM,EAFI,OAAA;AAGVC,UAAAA,MAAM,EAHI,MAAA;AAIV3B,UAAAA,OAAO,EAAEL,KAAI,IAAI,CAARA,QAAAA,GAAAA,cAAAA,GAJC,QAAA;AAKVI,UAAAA,QAAQ,EAAEuB,UAAU,CAAC5B,UAAU,CAArB4B,QAAU,CAAVA,IAAmC;AALnC,SAAZH;AAOA;AAvEqB,OAAA,CAyEvB;;;AACAI,MAAAA,WAAW,CAAC7B,UAAU,CAAtB6B,GAAW,CAAXA;AACD;;AACD,WAAA,MAAA;AACD;AAED;AACA;AACA;;;AACA,WAAA,KAAA,CAAA,OAAA,EAAwB;AACtB,WAAOV,OAAO,IAAIA,OAAO,CAAlBA,SAAAA,GAAAA,EAAAA,GAAP,GAAA;AACD;AAED;AACA;AACA;;;AACA,WAAA,cAAA,CAAA,MAAA,EAAA,IAAA,EAAA,OAAA,EAA+C;AAAA,QAAA,eAAA,GAMzCA,OANyC,CAAA,MAAA;AAAA,QAE3Ce,MAF2C,GAAA,eAAA,KAAA,KAAA,CAAA,GAAA,KAAA,GAAA,eAAA;AAAA,QAAA,cAAA,GAMzCf,OANyC,CAAA,KAAA;AAAA,QAG3CgB,KAH2C,GAAA,cAAA,KAAA,KAAA,CAAA,GAAA,IAAA,GAAA,cAAA;AAAA,QAAA,YAAA,GAMzChB,OANyC,CAAA,GAAA;AAAA,QAI3CZ,GAJ2C,GAAA,YAAA,KAAA,KAAA,CAAA,GAAA,IAAA,GAAA,YAAA;AAAA,QAAA,eAAA,GAMzCY,OANyC,CAAA,MAAA;AAAA,QAK3CiB,MAL2C,GAAA,eAAA,KAAA,KAAA,CAAA,GAKlC,UAAA,CAAA,EAAA;AAAA,aAAA,CAAA;AALkC,KAAA,GAAA,eAAA,CAAA,CAO7C;;AACA,QAAMC,QAAQ,GAAA,IAAA,MAAA,CAAOd,YAAY,CAACJ,OAAO,CAAPA,QAAAA,IAApB,EAAmB,CAAnB,EAR+B,KAQ/B,CAAd,CAR6C,CAS7C;;AACA,QAAMmB,SAAS,GAAA,IAAA,MAAA,CAAOf,YAAY,CAACJ,OAAO,CAAPA,SAAAA,IAApB,KAAmB,CAAnB,EAAf,GAAe,CAAf;AACA,QAAIoB,KAAK,GAAGJ,KAAK,GAAA,GAAA,GAX4B,EAW7C,CAX6C,CAa7C;;AAb6C,QAAA,SAAA,GAAA,0BAAA,CAAA,MAAA,CAAA;AAAA,QAAA,KAAA;;AAAA,QAAA;AAc7C,WAAA,SAAA,CAAA,CAAA,EAAA,EAAA,CAAA,CAAA,KAAA,GAAA,SAAA,CAAA,CAAA,EAAA,EAAA,IAAA,GAA4B;AAAA,YAAjBK,KAAiB,GAAA,KAAA,CAAA,KAAA,CAAA,CAC1B;;AACA,YAAI,OAAA,KAAA,KAAJ,QAAA,EAA+B;AAC7BD,UAAAA,KAAK,IAAIhB,YAAY,CAACa,MAAM,CAA5BG,KAA4B,CAAP,CAArBA;AADF,SAAA,MAEO;AACL;AACA,cAAMP,MAAM,GAAGT,YAAY,CAACa,MAAM,CAACI,KAAK,CAAxC,MAAkC,CAAP,CAA3B;AACA,cAAMP,MAAM,GAAGV,YAAY,CAACa,MAAM,CAACI,KAAK,CAHnC,MAG6B,CAAP,CAA3B,CAHK,CAKL;;AACA,cAAIA,KAAK,CAAT,OAAA,EAAmB;AACjB;AACA,gBAAA,IAAA,EAAU;AACRC,cAAAA,IAAI,CAAJA,IAAAA,CAAAA,KAAAA;AACD;;AAED,gBAAIT,MAAM,IAAV,MAAA,EAAsB;AACpB,kBAAIQ,KAAK,CAALA,QAAAA,KAAAA,GAAAA,IAA0BA,KAAK,CAALA,QAAAA,KAA9B,GAAA,EAAsD;AACpD;AACA,oBAAME,GAAG,GAAGF,KAAK,CAALA,QAAAA,KAAAA,GAAAA,GAAAA,GAAAA,GAAZ,EAAA;AACAD,gBAAAA,KAAK,IAAA,MAAA,MAAA,CAAA,MAAA,EAAA,MAAA,EAAA,MAAA,CAAuBC,KAAK,CAA5B,OAAA,EAAA,MAAA,EAAA,MAAA,CAAA,MAAA,EAAA,MAAA,CAAA,MAAA,EAAA,KAAA,EAAA,MAAA,CAAgEA,KAAK,CAArE,OAAA,EAAA,MAAA,EAAA,MAAA,CAAA,MAAA,EAAA,GAAA,EAAA,MAAA,CAALD,GAAK,CAALA;AAHF,eAAA,MAIO;AACLA,gBAAAA,KAAK,IAAA,MAAA,MAAA,CAAA,MAAA,EAAA,GAAA,EAAA,MAAA,CAAoBC,KAAK,CAAzB,OAAA,EAAA,GAAA,EAAA,MAAA,CAAA,MAAA,EAAA,GAAA,EAAA,MAAA,CAA+CA,KAAK,CAAzDD,QAAK,CAALA;AACD;AAPH,aAAA,MAQO;AACL;AACAA,cAAAA,KAAK,IAAA,IAAA,MAAA,CAAQC,KAAK,CAAb,OAAA,EAAA,GAAA,EAAA,MAAA,CAAyBA,KAAK,CAAnCD,QAAK,CAALA;AACD;AAjBH,WAAA,MAkBO;AACL;AACAA,YAAAA,KAAK,IAAA,MAAA,MAAA,CAAA,MAAA,EAAA,MAAA,CAAA,MAAA,EAAA,GAAA,EAAA,MAAA,CAA6BC,KAAK,CAAvCD,QAAK,CAALA;AACD;AACF;AA9C0C,OAAA,CAgD7C;;AAhD6C,KAAA,CAAA,OAAA,GAAA,EAAA;AAAA,MAAA,SAAA,CAAA,CAAA,CAAA,GAAA;AAAA,KAAA,SAAA;AAAA,MAAA,SAAA,CAAA,CAAA;AAAA;;AAiD7C,QAAA,GAAA,EAAS;AACP;AACA,UAAI,CAAJ,MAAA,EAAa;AACXA,QAAAA,KAAK,IAAA,GAAA,MAAA,CAAA,SAAA,EAALA,GAAK,CAALA;AAHK,OAAA,CAKP;;;AACAA,MAAAA,KAAK,IAAI,CAACpB,OAAO,CAAR,QAAA,GAAA,GAAA,GAAA,MAAA,MAAA,CAAA,QAAA,EAAToB,GAAS,CAATA;AANF,KAAA,MAOO;AACL;AACA,UAAMI,QAAQ,GAAGlC,MAAM,CAACA,MAAM,CAANA,MAAAA,GAAxB,CAAuB,CAAvB;AACA,UAAMmC,cAAc,GAClB,OAAA,QAAA,KAAA,QAAA,GACIN,SAAS,CAATA,OAAAA,CAAkBK,QAAQ,CAACA,QAAQ,CAARA,MAAAA,GAA3BL,CAA0B,CAA1BA,IAAmD,CADvD,CAAA,GAEI;AACAK,MAAAA,QAAQ,KAPT,SAGL,CAHK,CASL;;AACA,UAAI,CAAJ,MAAA,EAAa;AACXJ,QAAAA,KAAK,IAAA,MAAA,MAAA,CAAA,SAAA,EAAA,KAAA,EAAA,MAAA,CAAA,QAAA,EAALA,KAAK,CAALA;AAXG,OAAA,CAcL;;;AACA,UAAI,CAAJ,cAAA,EAAqB;AACnBA,QAAAA,KAAK,IAAA,MAAA,MAAA,CAAA,SAAA,EAAA,GAAA,EAAA,MAAA,CAAA,QAAA,EAALA,GAAK,CAALA;AACD;AACF;;AAED,WAAO,IAAA,MAAA,CAAA,KAAA,EAAkBM,KAAK,CAA9B,OAA8B,CAAvB,CAAP;AACD;AAED;AACA;AACA;;;AACA,WAAA,cAAA,CAAA,IAAA,EAAA,IAAA,EAAA,OAAA,EAA6C;AAC3C,WAAOC,cAAc,CAACC,KAAK,CAAA,IAAA,EAAN,OAAM,CAAN,EAAA,IAAA,EAArB,OAAqB,CAArB;AACD;AAED;AACA;AACA;;;AACA,WAAA,cAAA,CAAA,IAAA,EAAA,IAAA,EAAoC;AAClC;AACA,QAAI,CAAJ,IAAA,EAAW,OAFuB,IAEvB,CAFuB,CAGlC;;AACA,QAAMC,YAAY,GAAlB,yBAAA;AAEA,QAAIlC,KAAK,GAAT,CAAA;AACA,QAAImC,UAAU,GAAGD,YAAY,CAAZA,IAAAA,CAAkBtB,IAAI,CAAvC,MAAiBsB,CAAjB;;AACA,WAAA,UAAA,EAAmB;AACjBP,MAAAA,IAAI,CAAJA,IAAAA,CAAU;AACR;AACAxC,QAAAA,IAAI,EAAEgD,UAAU,CAAVA,CAAU,CAAVA,IAAiBnC,KAFf,EAAA;AAGRkB,QAAAA,MAAM,EAHE,EAAA;AAIRC,QAAAA,MAAM,EAJE,EAAA;AAKR5B,QAAAA,QAAQ,EALA,EAAA;AAMRC,QAAAA,OAAO,EAAE;AAND,OAAVmC;AAQAQ,MAAAA,UAAU,GAAGC,WAAW,CAAXA,IAAAA,CAAiBxB,IAAI,CAAlCuB,MAAaC,CAAbD;AACD;;AAED,WAAA,IAAA;AACD;AAED;AACA;AACA;;;AACA,WAAA,aAAA,CAAA,KAAA,EAAA,IAAA,EAAA,OAAA,EAA6C;AAC3C;AACA,QAAME,KAAK,GAAG,KAAK,CAAL,GAAA,CAAU,UAAA,IAAA,EAAA;AAAA,aAAUC,YAAY,CAAA,IAAA,EAAA,IAAA,EAAZA,OAAY,CAAZA,CAAV,MAAA;AAAxB,KAAc,CAAd;AACA,WAAO,IAAA,MAAA,CAAA,MAAA,MAAA,CAAiBD,KAAK,CAALA,IAAAA,CAAjB,GAAiBA,CAAjB,EAAA,GAAA,CAAA,EAAqCN,KAAK,CAAjD,OAAiD,CAA1C,CAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,WAAA,YAAA,CAAA,IAAA,EAAA,IAAA,EAAA,OAAA,EAA2C;AACzC;AACA,QAAInB,IAAI,YAAR,MAAA,EAA4B,OAAO2B,cAAc,CAAA,IAAA,EAArB,IAAqB,CAArB;AAC5B,QAAIC,KAAK,CAALA,OAAAA,CAAJ,IAAIA,CAAJ,EAAyB,OAAOC,aAAa,CAAA,IAAA,EAAA,IAAA,EAApB,OAAoB,CAApB;AACzB,WAAOC,cAAc,CAAA,IAAA,EAAA,IAAA,EAArB,OAAqB,CAArB;AACD;;AAED7D,EAAAA,OAAO,CAAPA,YAAAA,GAAAA,YAAAA;AAjbA,CAAyC,CAAzC;AAqbA8D,aAAa,CAAbA,cAAa,CAAbA;AACA,IAAIC,cAAc,GAAG5D,cAAc,CAAnC,YAAA;AAEA;AACA;AACA;;AACA,IAAI6D,KAAK,GAAT,EAAA;AACA,IAAIC,aAAa,GAAjB,EAAA;AACA,IAAMC,UAAU,GAAhB,KAAA;AACA,IAAIC,UAAU,GAAd,CAAA;AACA;AACA;AACA;AACA;AACA;;AACA,SAAA,WAAA,CAAA,IAAA,EAAyC;AAAA,MAAd3C,OAAc,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAJ,EAAI;;AACxC,MAAIwC,KAAK,CAAT,IAAS,CAAT,EAAiB;AAChB,WAAOA,KAAK,CAAZ,IAAY,CAAZ;AACA;;AACD,MAAIlB,IAAI,GAAR,EAAA;AACA,MAAMsB,MAAM,GAAGL,cAAc,CAAA,IAAA,EAAA,IAAA,EAA7B,OAA6B,CAA7B;AACA,MAAMjC,MAAM,GAAG;AAAEsC,IAAAA,MAAM,EAAR,MAAA;AAAUtB,IAAAA,IAAI,EAAJA;AAAV,GAAf;;AAEA,MAAIqB,UAAU,GAAd,UAAA,EAA6B;AAC5BH,IAAAA,KAAK,CAALA,IAAK,CAALA,GAAAA,MAAAA;AACAC,IAAAA,aAAa,CAAbA,IAAAA,CAAAA,IAAAA;AACAE,IAAAA,UAAU;AAHX,GAAA,MAIO;AACN;AACA,QAAME,UAAU,GAAGJ,aAAa,CAAhC,KAAmBA,EAAnB;AACA,WAAOD,KAAK,CAAZ,UAAY,CAAZ;AACAA,IAAAA,KAAK,CAALA,IAAK,CAALA,GAAAA,MAAAA;AACAC,IAAAA,aAAa,CAAbA,IAAAA,CAAAA,IAAAA;AACA;;AACD,SAAA,MAAA;AACA;AAED;AACA;AACA;AACA;AACA;;;AACA,SAAA,SAAA,CAAA,YAAA,EAA+C;AAAA,MAAdzC,OAAc,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAJ,EAAI;;AAC9C,MAAI,OAAA,OAAA,KAAA,QAAA,IAA+BmC,KAAK,CAALA,OAAAA,CAAnC,OAAmCA,CAAnC,EAA2D;AAC1DnC,IAAAA,OAAO,GAAG;AAAEO,MAAAA,IAAI,EAAEP;AAAR,KAAVA;AACA;;AAH6C,MAAA,QAAA,GAAA,OAAA;AAAA,MAK7CO,IAL6C,GAAA,QAAA,CAAA,IAAA;AAAA,MAAA,cAAA,GAAA,QAAA,CAAA,KAAA;AAAA,MAM7CuC,KAN6C,GAAA,cAAA,KAAA,KAAA,CAAA,GAAA,KAAA,GAAA,cAAA;AAAA,MAAA,gBAAA,GAAA,QAAA,CAAA,MAAA;AAAA,MAO7C/B,MAP6C,GAAA,gBAAA,KAAA,KAAA,CAAA,GAAA,KAAA,GAAA,gBAAA;AAAA,MAAA,kBAAA,GAAA,QAAA,CAAA,SAAA;AAAA,MAQ7CgC,SAR6C,GAAA,kBAAA,KAAA,KAAA,CAAA,GAAA,KAAA,GAAA,kBAAA,CAAA,CAW9C;;AACA,MAAMC,KAAK,GAAG,GAAA,MAAA,CAZgC,IAYhC,CAAd,CAZ8C,CAa9C;;AACA,SAAO,KAAK,CAAL,MAAA,CAAa,UAAA,OAAA,EAAA,IAAA,EAAmB;AACtC,QAAI,CAAA,IAAA,IAASzC,IAAI,KAAjB,EAAA,EAA0B,OAAA,IAAA;AAC1B,QAAA,OAAA,EAAa,OAAA,OAAA;AACb,QAAMP,OAAO,GAAG;AACfZ,MAAAA,GAAG,EADY,KAAA;AAEf2B,MAAAA,MAAM,EAFS,MAAA;AAGfgC,MAAAA,SAAS,EAATA;AAHe,KAAhB,CAHsC,CAQtC;;AARsC,QAAA,YAAA,GASbE,WAAW,CAAA,IAAA,EATE,OASF,CATE;AAAA,QAS9BL,MAT8B,GAAA,YAAA,CAAA,MAAA;AAAA,QAStBtB,IATsB,GAAA,YAAA,CAAA,IAAA,CAAA,CAWtC;;;AACA,QAAM4B,KAAK,GAAGN,MAAM,CAANA,IAAAA,CAAd,YAAcA,CAAd;AAEA,QAAI,CAAJ,KAAA,EAAY,OAd0B,IAc1B,CAd0B,CAetC;;AAfsC,QAAA,MAAA,GAAA,0BAAA,KAAA,CAAA;AAAA,QAgB/BO,GAhB+B,GAAA,MAAA,CAAA,CAAA,CAAA;AAAA,QAgBvBC,MAhBuB,GAAA,MAAA,CAAA,KAAA,CAAA,CAAA,CAAA;;AAiBtC,QAAMC,OAAO,GAAGC,YAAY,KAjBU,GAiBtC,CAjBsC,CAmBtC;;AACA,QAAIR,KAAK,IAAI,CAAb,OAAA,EAAuB,OApBe,IAoBf,CApBe,CAqBtC;;AACA,WAAO;AACNvC,MAAAA,IAAI,EADE,IAAA;AACA;AACN4C,MAAAA,GAAG,EAAE5C,IAAI,KAAJA,GAAAA,IAAgB4C,GAAG,KAAnB5C,EAAAA,GAAAA,GAAAA,GAFC,GAAA;AAEuC;AAC7C8C,MAAAA,OAAO,EAHD,OAAA;AAGG;AACTE,MAAAA,MAAM,EAAE,IAAI,CAAJ,MAAA,CAAY,UAAA,IAAA,EAAA,GAAA,EAAA,KAAA,EAAsB;AACzC;AACAC,QAAAA,IAAI,CAAChD,GAAG,CAARgD,IAAI,CAAJA,GAAiBJ,MAAM,CAAvBI,KAAuB,CAAvBA;AACA,eAAA,IAAA;AAHO,OAAA,EAAA,EAAA;AAJF,KAAP;AAtBM,GAAA,EAAP,IAAO,CAAP;AAiCA;;AAEDhF,OAAO,CAAPA,WAAAA,GAAAA,WAAAA;AACAA,OAAO,CAAPA,SAAAA,GAAAA,SAAAA","sourcesContent":["'use strict';\r\n\r\nObject.defineProperty(exports, '__esModule', { value: true });\r\n\r\nfunction unwrapExports (x) {\r\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\r\n}\r\n\r\nfunction createCommonjsModule(fn, module) {\r\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\r\n}\r\n\r\nvar pathToRegexp_1 = createCommonjsModule(function (module, exports) {\r\n\r\nObject.defineProperty(exports, '__esModule', { value: true });\r\n\r\n// 词法分析类型\r\nconst tokensType = {\r\n  name: \"NAME\", // 名称\r\n  char: \"CHAR\", // 字符\r\n  open: \"OPEN\", // 开\r\n  close: \"CLOSE\", // 关\r\n  escapedChar: \"ESCAPED_CHAR\", // 分割符\r\n  modifier: \"MODIFIER\", // 修饰符\r\n  pattern: \"PATTERN\", // 范式 是用来描述name的\r\n  end: \"END\", // 结束\r\n};\r\n\r\n/**\r\n * 拆分string\r\n */\r\nfunction escapeString(str) {\r\n  // 将非 ! : $ { } ( ) [ ] / \\ 的都按照转义字符处理,实际上看起来就是将通用的正则表达式中不是数据处理的数据全部剔除\r\n  return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\r\n}\r\n\r\n/**\r\n * 词法分析\r\n * 实际上是分词,只不过这一步的分词主要是处理 范式(pattern) 和 字段名称(name) 这两种类型,其他的情况都简单处理,每个char都可以单独展示\r\n * @param {Array} str\r\n */\r\nfunction lexer(str) {\r\n  let tokens = [];\r\n  let i = 0;\r\n  const strLength = str.length;\r\n  while (i < strLength) {\r\n    const char = str[i];\r\n\r\n    // 处理修饰符\r\n    if (char === \"*\" || char === \"+\" || char === \"?\") {\r\n      tokens.push({ type: tokensType.modifier, index: i, value: char });\r\n      i++;\r\n      continue;\r\n    }\r\n    // 处理分割符\r\n    if (char === \"\\\\\") {\r\n      // TODO 这里和源码实现不一样，源码中应该是将多过了一个字符串\r\n      tokens.push({ type: tokensType.escapedChar, index: i, value: char });\r\n      i++;\r\n      continue;\r\n    }\r\n    // 处理开标签 {\r\n    if (char === \"{\") {\r\n      tokens.push({ type: tokensType.open, index: i, value: char });\r\n      i++;\r\n      continue;\r\n    }\r\n    // 处理闭标签 }\r\n    if (char === \"}\") {\r\n      tokens.push({ type: tokensType.close, index: i, value: char });\r\n      i++;\r\n      continue;\r\n    }\r\n\r\n    // 处理定义的随机类型name\r\n    if (char === \":\") {\r\n      let name = \"\";\r\n      let j = i + 1;\r\n      // 变量只能是0-9 a-z A-Z _(下滑线),这和很多的编程语言中变量的定义是一致的\r\n      while (j < strLength) {\r\n        const code = str.charCodeAt(j);\r\n\r\n        if (\r\n          // `0-9`\r\n          (code >= 48 && code <= 57) ||\r\n          // `A-Z`\r\n          (code >= 65 && code <= 90) ||\r\n          // `a-z`\r\n          (code >= 97 && code <= 122) ||\r\n          // `_`\r\n          code === 95\r\n        ) {\r\n          name += str[j++];\r\n          continue;\r\n        }\r\n\r\n        break;\r\n      }\r\n      // 如果名称不存在,则提示类型错误\r\n      if (!name) throw new TypeError(`Missing parameter name at ${i}`);\r\n      tokens.push({ type: tokensType.name, index: i, value: name });\r\n      // 跨国中间的值,直接到name之后\r\n      i = j;\r\n      continue;\r\n    }\r\n\r\n    // 处理pattern范式的情况\r\n    if (char === \"(\") {\r\n      let j = i + 1;\r\n      let pattern = \"\";\r\n      // 用来判断是否闭合\r\n      let count = 1;\r\n\r\n      if (str[j] === \"?\") {\r\n        throw new SyntaxError(`Pattern cannot start with \"?\" at ${j}`);\r\n      }\r\n\r\n      while (j < strLength) {\r\n        const patternChar = str[j];\r\n        // 如果是 \\ ,则添加两次,因为在比较的时候,字符串\\\\ 会被转义成 \\ 所以实际上一个\\对应两个字符,需要加两次\r\n        if (patternChar === \"\\\\\") {\r\n          pattern += str[j++] + str[j++];\r\n          continue;\r\n        }\r\n\r\n        if (patternChar === \")\") {\r\n          // 如果是)就闭合判断结束\r\n          count--;\r\n          if (count === 0) {\r\n            j++;\r\n            break;\r\n          }\r\n        } else if (patternChar === \"(\") {\r\n          // 套娃\r\n          count++;\r\n          if (str[j + 1] !== \"?\") {\r\n            throw new TypeError(`Capturing groups are not allowed at ${j}`);\r\n          }\r\n        }\r\n\r\n        pattern += str[j++];\r\n      }\r\n      // count 存在说明没有完全闭合或者闭合过多了\r\n      if (count) throw new TypeError(`Unbalanced pattern at ${i}`);\r\n      if (!pattern) throw new TypeError(`Missing pattern at ${i}`);\r\n\r\n      tokens.push({ type: tokensType.pattern, index: i, value: pattern });\r\n      i = j;\r\n      continue;\r\n    }\r\n\r\n    // 不是以上各种情况,就全部认为是 字符 (char)\r\n    tokens.push({ type: tokensType.char, index: i, value: str[i++] });\r\n  }\r\n  tokens.push({ type: tokensType.end, index: i, value: \"\" });\r\n  return tokens;\r\n}\r\n\r\n/**\r\n * 根据词法分析结果 分词 ,或者说是生成一个标准化的数组,用于后续连续性处理\r\n * 返回字符串或者 词法对象\r\n * 词法对象结构\r\n * {\r\n *      modifier:'', // 修饰符\r\n        name:'test', // 名称\r\n        pattern:'[^\\\\/#\\\\?]+?', // 范式（用于实际匹配）\r\n        prefix:'/', // 前缀\r\n        suffix:'', // 后缀\r\n * }\r\n */\r\n// TODO 后续可以考虑将分词器和格式化的统一整合，直接输出分词结果\r\nfunction parse(str, options = {}) {\r\n  const tokens = lexer(str);\r\n  const { prefixes = \"./\" } = options;\r\n  // defaultPattern 应该是一个特性的范式,用来匹配任意值即可,实际上用排除法,在路由的判断里,不能算在路由中的实际上只有 /(pathname) #(hash) ?(search)\r\n  const defaultPattern = `[^${escapeString(options.delimiter || \"/#?\")}]+?`;\r\n  let i = 0;\r\n  const tokensLength = tokens.length;\r\n  let result = [];\r\n  let path = \"\";\r\n  let key = 0;\r\n\r\n  /**\r\n   * 尝试获取指定类型的值,不存在则返回null\r\n   */\r\n  const tryConsume = (type) => {\r\n    let result = null;\r\n    if (i < tokensLength && tokens[i].type === type) {\r\n      result = tokens[i].value;\r\n      i++;\r\n    }\r\n    return result;\r\n  };\r\n\r\n  /**\r\n   * 必须获取指定值,如果不是指定值则报错\r\n   */\r\n  var mustConsume = function (type) {\r\n    const value = tryConsume(type);\r\n    // 满足期望,则返回值\r\n    if (value !== undefined) {\r\n      return value;\r\n    }\r\n    // 不满足期望则提示\r\n    const { type: nextType, index } = tokens[i];\r\n    throw new TypeError(`Unexpected ${nextType} at ${index}, expected ${type}`);\r\n  };\r\n  /**\r\n   * 获取固定的前缀\r\n   */\r\n  var consumeText = function () {\r\n    let result = \"\";\r\n    var value;\r\n    while (\r\n      (value =\r\n        tryConsume(tokensType.char) || tryConsume(tokensType.escapedChar))\r\n    ) {\r\n      result += value;\r\n    }\r\n    return result;\r\n  };\r\n\r\n  while (i < tokensLength) {\r\n    // 获取char\r\n    const char = tryConsume(tokensType.char);\r\n    // 获取name 和 pattern\r\n    const name = tryConsume(tokensType.name);\r\n    const pattern = tryConsume(tokensType.pattern);\r\n    // name 或者 pattern 存在说明了存在匹配类型,从本质上看,这两种情况的处理逻辑是一致的,都是设置name值,然后设置范式\r\n    if (name || pattern) {\r\n      // 前缀默认为char的值\r\n      const prefix = char || \"\";\r\n      /**\r\n       * 如果前缀不存在,则表明char是path的一部分,如果前缀存在则直接作为前缀使用即可,还存在一种特殊的场景,就是固定的值后又匹配了对应的数据,是一个动态的路由\r\n       * 举一个例子,动态路由的前缀都是/detail + 对应详情id的形式,用于的场景可能是埋点等,暂时考虑不到实际的使用用途,但是应该有存在的可能性\r\n       */\r\n      if (prefixes.indexOf(prefix) === -1) {\r\n        path += prefix;\r\n        prefix = \"\";\r\n      }\r\n      /**\r\n       * 如果path存在就直接设置了path,因为对于path存在的场景,数据是固定了路由的,所以范式和配置的其他条件都是没有用的\r\n       * 没有前缀的时候,实际上说明上一个数据是一个的固定值,这就可能是一个动态路由的场景\r\n       */\r\n      if (path) {\r\n        result.push(path);\r\n        path = \"\";\r\n      }\r\n      // 需要按照动态参数的匹配场景处理,有name就使用name,没有就默认key值即可,对于一个url而言,实际上基本key不会太多,修饰符标识1个多个的关系,就是正则表达式中的+ ? *\r\n      result.push({\r\n        name: name || key++,\r\n        prefix,\r\n        suffix: \"\",\r\n        pattern: pattern || defaultPattern,\r\n        modifier: tryConsume(tokensType.modifier) || \"\",\r\n      });\r\n      continue;\r\n    }\r\n\r\n    // 分割符当作是路由的一部分,可能属于一种奇怪的路由形式,其他情况就是不断的拼接char,知道无法拼接完成(本质上是将之前拆分的分词组合起来)\r\n    const value = char || tryConsume(tokensType.escapedChar);\r\n    if (value) {\r\n      path += value;\r\n      continue;\r\n    }\r\n\r\n    // 如果path存在就直接填充\r\n    if (path) {\r\n      result.push(path);\r\n      path = \"\";\r\n      continue;\r\n    }\r\n\r\n    const open = tryConsume(tokensType.open);\r\n    if (open) {\r\n      /**\r\n       * open中的内容实际上也只包含三种类型,首先前面char类型的,一开始获取到的char类型的实际上都是前缀,因为这部分是不变的\r\n       * 然后获取到的类型为 name 和 pattern 两种,  最后的char类型按照后缀来\r\n       * 但是必须要open close 组合结尾,不能多个open,这种情况不做处理\r\n       */\r\n      const prefix = consumeText();\r\n      const name = tryConsume(tokensType.name) || \"\";\r\n      const pattern = tryConsume(tokensType.pattern) || \"\";\r\n      const suffix = consumeText();\r\n      mustConsume(tokensType.close);\r\n      // 插入判断类型,name只有在存在 name 或者 pattern 的时候才是有价值的，否则实际上就是一个固定值\r\n      result.push({\r\n        name: name || (pattern ? key++ : \"\"),\r\n        prefix,\r\n        suffix,\r\n        pattern: name && !pattern ? defaultPattern : pattern,\r\n        modifier: tryConsume(tokensType.modifier) || \"\",\r\n      });\r\n      continue;\r\n    }\r\n    // 当所有的情况都不匹配的时候,必须是end结尾\r\n    mustConsume(tokensType.end);\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * 判断是否区分大小写\r\n */\r\nfunction flags(options) {\r\n  return options && options.sensitive ? \"\" : \"i\";\r\n}\r\n\r\n/**\r\n * 将分词处理过的数据,转换成正则表达式\r\n */\r\nfunction tokensToRegexp(tokens, keys, options) {\r\n  const {\r\n    strict = false,\r\n    start = true,\r\n    end = true,\r\n    encode = (x) => x,\r\n  } = options;\r\n  // 设置的结尾字符转义化处理\r\n  const endsWith = `[${escapeString(options.endsWith || \"\")}]|$`;\r\n  // 匹配的最后一个词的转义化处理\r\n  const delimiter = `[${escapeString(options.delimiter || \"/#?\")}]`;\r\n  let route = start ? \"^\" : \"\";\r\n\r\n  // 遍历分词数组\r\n  for (const token of tokens) {\r\n    // 如果是字符串就直接拼接到route中\r\n    if (typeof token === \"string\") {\r\n      route += escapeString(encode(token));\r\n    } else {\r\n      // 分词对象的时候，先处理前后缀的正则\r\n      const prefix = escapeString(encode(token.prefix));\r\n      const suffix = escapeString(encode(token.suffix));\r\n\r\n      // 如果存在范式\r\n      if (token.pattern) {\r\n        // 设置在keys中主要是为了后续处理url中params数据\r\n        if (keys) {\r\n          keys.push(token);\r\n        }\r\n\r\n        if (prefix || suffix) {\r\n          if (token.modifier === \"+\" || token.modifier === \"*\") {\r\n            // 将 + 和 * 单独处理了，即手动的设置一个存在的，然后再设置一个* 的，然后整体为 ?\r\n            const mod = token.modifier === \"*\" ? \"?\" : \"\";\r\n            route += `(?:${prefix}((?:${token.pattern})(?:${suffix}${prefix}(?:${token.pattern}))*)${suffix})${mod}`;\r\n          } else {\r\n            route += `(?:${prefix}(${token.pattern})${suffix})${token.modifier}`;\r\n          }\r\n        } else {\r\n          // 没有前后缀就直接设置正则即可\r\n          route += `(${token.pattern})${token.modifier}`;\r\n        }\r\n      } else {\r\n        // TODO 没有范式，说明是??? ,没考虑清楚\r\n        route += `(?:${prefix}${suffix})${token.modifier}`;\r\n      }\r\n    }\r\n  }\r\n  // 是否字符串的结尾匹配\r\n  if (end) {\r\n    // 允许尾部分割符处理\r\n    if (!strict) {\r\n      route += `${delimiter}?`;\r\n    }\r\n    // 是否设置结束字符，如果没有则默认为$ 否则指定固定值\r\n    route += !options.endsWith ? \"$\" : `(?=${endsWith})`;\r\n  } else {\r\n    // 如果最后以是字符串，则判断是否是尾部分割符\r\n    const endToken = tokens[tokens.length - 1];\r\n    const isEndDelimited =\r\n      typeof endToken === \"string\"\r\n        ? delimiter.indexOf(endToken[endToken.length - 1]) > -1\r\n        : // tslint:disable-next-line\r\n          endToken === undefined;\r\n\r\n    // 允许尾部分割符处理\r\n    if (!strict) {\r\n      route += `(?:${delimiter}(?=${endsWith}))?`;\r\n    }\r\n\r\n    // 最后一个不是结束分割符的时候，手动添加\r\n    if (!isEndDelimited) {\r\n      route += `(?=${delimiter}|${endsWith})`;\r\n    }\r\n  }\r\n\r\n  return new RegExp(route, flags(options));\r\n}\r\n\r\n/**\r\n * 字符串处理\r\n */\r\nfunction stringToRegexp(path, keys, options) {\r\n  return tokensToRegexp(parse(path, options), keys, options);\r\n}\r\n\r\n/**\r\n * 正则转正则\r\n */\r\nfunction regexpToRegexp(path, keys) {\r\n  // 正则的处理如果没有keys的，直接返回即可\r\n  if (!keys) return path;\r\n  // TODO 只明白了要将 没懂  \\( 开头   (?:\\?<(.*?)>) 非获取匹配?<任意值> 的数据    (.*?) 任意字符存在0个或1个，并获取      (?!\\?) 为非?\r\n  const groupsRegexp = /\\((?:\\?<(.*?)>)?(?!\\?)/g;\r\n\r\n  let index = 0;\r\n  let execResult = groupsRegexp.exec(path.source);\r\n  while (execResult) {\r\n    keys.push({\r\n      // Use parenthesized substring match if available, index otherwise\r\n      name: execResult[1] || index++,\r\n      prefix: \"\",\r\n      suffix: \"\",\r\n      modifier: \"\",\r\n      pattern: \"\",\r\n    });\r\n    execResult = groupsRegex.exec(path.source);\r\n  }\r\n\r\n  return path;\r\n}\r\n\r\n/**\r\n * 数组转正则\r\n */\r\nfunction arrayToRegexp(paths, keys, options) {\r\n  // 循环调用paths，每个单独处理，然后生成一个| 的匹配形式的正则\r\n  const parts = paths.map((path) => pathToRegexp(path, keys, options).source);\r\n  return new RegExp(`(?:${parts.join(\"|\")})`, flags(options));\r\n}\r\n\r\n/**\r\n *\r\n * @param {String|Array|RegExp} path\r\n * @param {Array} keys\r\n * @param {Object} options\r\n */\r\nfunction pathToRegexp(path, keys, options) {\r\n  // TODO 数组和正则的都不太了解使用场景\r\n  if (path instanceof RegExp) return regexpToRegexp(path, keys);\r\n  if (Array.isArray(path)) return arrayToRegexp(path, keys, options);\r\n  return stringToRegexp(path, keys, options);\r\n}\r\n\r\nexports.pathToRegexp = pathToRegexp;\r\n//# sourceMappingURL=path-to-regexp.js.map\r\n});\r\n\r\nunwrapExports(pathToRegexp_1);\r\nvar pathToRegexp_2 = pathToRegexp_1.pathToRegexp;\r\n\r\n/**\r\n * 缓存判断过的数据\r\n */\r\nlet cache = {};\r\nlet cachePathList = [];\r\nconst cacheLimit = 10000;\r\nlet cacheCount = 0;\r\n/**\r\n * 比较判断path\r\n * @param {*} path\r\n * @param {*} options\r\n */\r\nfunction compilePath(path, options = {}) {\r\n\tif (cache[path]) {\r\n\t\treturn cache[path];\r\n\t}\r\n\tlet keys = [];\r\n\tconst regexp = pathToRegexp_2(path, keys, options);\r\n\tconst result = { regexp, keys };\r\n\r\n\tif (cacheCount < cacheLimit) {\r\n\t\tcache[path] = result;\r\n\t\tcachePathList.push(path);\r\n\t\tcacheCount++;\r\n\t} else {\r\n\t\t// 这里采用操作系统的缓存算法，考虑到整体的复杂度，感觉还是使用先进先出算法(FIFO)容易一点，可以考虑其他缓存算法\r\n\t\tconst removePath = cachePathList.shift();\r\n\t\tdelete cache[removePath];\r\n\t\tcache[path] = result;\r\n\t\tcachePathList.push(path);\r\n\t}\r\n\treturn result;\r\n}\r\n\r\n/**\r\n * 判断是否符合路由条件\r\n * @param {*} path\r\n * @param {*} target\r\n */\r\nfunction matchPath(locationPath, options = {}) {\r\n\tif (typeof options === \"string\" || Array.isArray(options)) {\r\n\t\toptions = { path: options };\r\n\t}\r\n\tconst {\r\n\t\tpath, // 地址\r\n\t\texact = false, // 用于匹配结尾\r\n\t\tstrict = false, // 详细匹配\r\n\t\tsensitive = false, // 大小写敏感,true 不区分 false区分\r\n\t} = options;\r\n\r\n\t// 避免options 是 数组的情况\r\n\tconst paths = [].concat(path);\r\n\t// 只处理数组的第一个，其他\r\n\treturn paths.reduce((matched, path) => {\r\n\t\tif (!path && path !== \"\") return null;\r\n\t\tif (matched) return matched;\r\n\t\tconst options = {\r\n\t\t\tend: exact,\r\n\t\t\tstrict,\r\n\t\t\tsensitive,\r\n\t\t};\r\n\t\t// 生成path的正则表达式\r\n\t\tconst { regexp, keys } = compilePath(path, options);\r\n\r\n\t\t// 判断是否匹配路由哦\r\n\t\tconst match = regexp.exec(locationPath);\r\n\r\n\t\tif (!match) return null;\r\n\t\t// 第一个值是匹配到的url内容，后面的对应:test 这种动态路由的值\r\n\t\tconst [url, ...values] = match;\r\n\t\tconst isExact = locationPath === url;\r\n\r\n\t\t// 不匹配的时候返回null\r\n\t\tif (exact && !isExact) return null;\r\n\t\t// TODO 这里需要考虑一个问题，如果存在两个都能匹配到的路由的时候，优先级是怎么样的\r\n\t\treturn {\r\n\t\t\tpath, // the path used to match\r\n\t\t\turl: path === \"/\" && url === \"\" ? \"/\" : url, // the matched portion of the URL\r\n\t\t\tisExact, // whether or not we matched exactly\r\n\t\t\tparams: keys.reduce((memo, key, index) => {\r\n\t\t\t\t// 生成params对象\r\n\t\t\t\tmemo[key.name] = values[index];\r\n\t\t\t\treturn memo;\r\n\t\t\t}, {}),\r\n\t\t};\r\n\t}, null);\r\n}\r\n\r\nexports.compilePath = compilePath;\r\nexports.matchPath = matchPath;\r\n//# sourceMappingURL=router-match.js.map\r\n"]},"metadata":{},"sourceType":"script"}
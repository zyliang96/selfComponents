# 4 月 15 日题目

## 一、Token 一般是存放在哪里？Token 放在 Cookie 和 放在 localStorage 、 sessionStorage 中有什么不同？

token 存放在哪里都是可以的，取决于选择的策略，和想要实现的效果，具体的问题需要具体分析

token 存放在 Cookie 中 使用 HttpOnly 标记的 Cookie 只能使用在 HTTP 请求过程中，所以无法通过 JavaScript 来读取这段 Cookie。如果使用 HttpOnly 则可以正常获取，SameSite 属性设置的情况下，只可在自己站点内访问的时候流转，否则其他页面打开的页面，则不能够正常访问到 cookie，但是 由于 cookie 支持存储的数据较小，如果 token 过长，则有可能超出保存范围。

localStorage 和 sessionStorage 都是存在本地的，在发送请求的时候，浏览器不能自动将这些数据装填到请求头中，需要人为操作传递，在使用上较为麻烦，

- Token 其实就是访问资源的凭证。

- 一般是用户通过用户名和密码登录成功之后，服务器将登陆凭证做数字签名，加密之后得到的字符串作为 token。

- 它在用户登录成功之后会返回给客户端，客户端主要有这么几种存储方式：

  1.1 存储在 localStorage 中，每次调用接口的时候都把它当成一个字段传给后台

  1.2 存储在 cookie 中，让它自动发送，不过缺点就是不能跨域

  1.3 拿到之后存储在 localStorage 中，每次调用接口的时候放在 HTTP 请求头的 Authorization 字段里

- 所以 token 在客户端一般存放于 localStorage，cookie，或 sessionStorage 中。

- 将 token 存放在 webStroage 中，可以通过同域的 js 来访问 。这样会导致很容易受到 xss 攻击，特别是项目中引入很多 第三方 js 类库的情况下。如果 js 脚本被盗用，攻击者就 可以轻易访问你的网站，webStroage 作为一种储存机制，在传输过程中不会执行任何安全标准。

- XSS 攻击：cross-site Scripting（跨站脚本攻击）是一种注入代码攻击 。恶意攻击者在目标网站上注入 script 代码，当访问者浏览网站的时候通过执行注入的 script 代码达到窃取用户信息，盗用用户身份等。

- 将 token 存放在 cookie 中可以指定 httponly，来防止被 Javascript 读取，也可以指定 secure，来保证 token 只在 HTTPS 下传输。缺点是不符合 Restful 最佳实践，容易受到 CSRF 攻击。

- CSRF 跨站点请求伪造(Cross—Site Request Forgery)，跟 XSS 攻击一样，存在巨大的危害性。简单来说就是恶意攻击者盗用已经认证过的用户信息，以用户信息名义进行一些操作（如发邮件、转账、购买商品等等）。由于身份已经认证过，所以目标网站会认为操作都是真正的用户操作的 。CSRF 并不能拿到用户信息，它只是盗用的用户凭证去进行操作。

## 二、webSocket 是怎么实现点对点通信和广播通信的？

WebSocket 处于应用层，也是基于 TCP（3 次握手，TCP 通信的原理）实现的。

TCP 长连接流程：

client 向 server 发起连接，server 接受 client 连接。双方建立连接，Client 与 server 完成一次读写之后，它们之间的连接并不会主动关闭，用心跳保活。后续的读写操作会继续使用这个连接。

一旦 WebSocket 连接建立后，后续数据都以帧序列的形式传输。在客户端或 Server 端中断连接前，不需要客户端和服务端重新发起连接请求。

发起握手：
每个 WebSocket 连接都始于一个 HTTP 请求。
具体来说，WebSocket 协议在第一次握手连接时，通过 HTTP 协议在传送数据，但是比普通 HTTP 请求相比多了一些字段。

客户端

```
GET /chat HTTP/1.1
    Upgrade: websocket    //转换的是websocket协议
    Connection: Upgrade  //本次通信协议升级
    Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ== //一个Base64 encode的值，这个是浏览器随机生成的　　　　
    Sec-WebSocket-Protocol: chat, superchat//个用户定义的字符串，用来区分同URL下，不同的服务所需要的协议
    Sec-WebSocket-Version: 13 //websocket协议版本
```

服务器：

```
    HTTP/1.1 101 Switching Protocols //101  协议经过了转换并握手成功建立起了通信。
　　Upgrade: websocket
    Connection: Upgrade
    Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
    Sec-WebSocket-Protocol: cha
```

webSocket 是一种全双工通信协议。websocket 让服务端和客户端通信变得简单。最大的特点是可以通过服务端主动推送消息到客户端。前端基于 nodejs 和 WebSocket 实现 点对点 及广播通信。

广播通信顾名思义是类似广播一样给多个人进行广播消息。实现广播通信可以使用很多模块 主要能够把流程描述清楚就可以了。我这里采取的是 socket.io 模块。服务端监听 socket 链接：

```js
io.on("connection", (socket) => {
	console.log("有socket连接");
});
```

通过监听连接过来的 socket 对象广播对应的信息：

```js
socket.on("addData", function (data) {
	//广播除了自己之外的其他订阅者
	socket.broadcast.emit("addInputData", data);
});
```

客户端连接及发送对应的 socket 请求：

```js
let socket = io.connect("ws://localhost:3000"); //连接socket服务器
socket.emit("addData", JSON.stringify(info)); //发送socket事件
```

点对点通信顾名思义就是一对一的通信，例如多人实时聊天，可以指定用户来发送消息 。点对点通信中需要注意服务端需要记录每个 socket 客户端的连接 ，需要将客户端及服务端 socket 对象关联起来。广播数据的时候，广播指定对象就可以了。如下：

服务端记录每一个连接过来的 socket 对象，且和用户 id 进行关联：

```js
socket.on("uid", (data) => {
	usersObj[data] = socket; //通过usersObj来记录连接过来的用户
});
```

给指定的 socket 对象进行广播：

```js
socket.on("user", (data) => {
	let uid = JSON.parse(data).uid;
	userObj[uid].emit("content", data);
});
```

客户端监听点对点广播事件：

```js
socket.on("content", function (data) {
	console.log(data);
});
```

总结，WebSocket 区分广播通信及点对点通信核心在于区分每一个连接的 socket 对象。广播通信需要对于非自身的所有连接的 socket 对象进行通信。而点对点通信，通过关联用户及 socket 对象，且保存每一个 socket 连接，查找指定的 socket 对象，来达到发送指定 socket 连接的目的。

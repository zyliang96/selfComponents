# 4 月 8 日题目

## 一、Vue 中 computed 和 watch 区别？

计算属性 computed :

-   支持缓存，只有依赖数据发生改变，才会重新进行计算
-   不支持异步，当 computed 内有异步操作时无效，无法监听数据的变化
-   computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于 data 中声明过或者父组件传递的 props 中的数据通过计算得到的值
-   如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用 computed
-   如果 computed 属性属性值是函数，那么默认会走 get 方法；函数的返回值就是属性的属性值；在 computed 中的，属性都有一个 get 和一个 set 方法，当数据变化时，调用 set 方法。

computed 中的属性名不能和 data 中的属性名重复，本质上讲，计算属性和 data 中的值是类似的，只不过它的属性计算依赖于数据变化

侦听属性 watch：

-   不支持缓存，数据变，直接会触发相应的操作；
-   watch 支持异步
-   监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；
-   当一个属性发生变化时，需要执行对应的操作；一对多；
-   监听数据必须是 data 中声明过或者父组件传递过来的 props 中的数据，当数据变化时，触发其他操作，函数有两个参数，
    handler：相应方法
    　　 immediate：组件加载立即触发回调函数执行，
    　　 deep: 深度监听，为了发现对象内部值的变化，复杂类型的数据时使用，例如数组中的对象内容的改变，注意监听数组的变动不需要这么做。注意：deep 无法监听到数组的变动和对象的新增，参考 vue 数组变异,只有以响应式的方式触发才会被监听到。

watch 实际上是为了简化数据响应式变化后处理操作的，这个类似 react 中 useEffect 的作用

## 二、React 中组件间通信都有哪些形式？

### Props

`props`适用于父子组件的通信，`props`以单向数据流的形式可以很好的完成父子组件的通信，所谓单向数据流，就是数据只能通过 props 由父组件流向子组件，而子组件并不能通过修改 props 传过来的数据修改父组件的相应状态，所有的 props 都使得其父子 props 之间形成了一个单向下行绑定，数据的更新和流向都是自上向下流动的，不能反过来。实际上如果传入一个基本数据类型给子组件，在子组件中修改这个值的话 React 中会抛出异常，如果对于子组件传入一个引用类型的对象的话，在子组件中修改是不会出现任何提示的（因为引用类型指针的执行是没有变的，所以判断地址没有发生变化，所以不会提示错误），但这两种情况都属于改变了父子组件的单向数据流，是不符合可维护的设计方式的。这种单向的数据流向可以清楚的看到数据是哪里发起的变动，可以追根溯源，从而避免了在项目逐步扩大后，发生数据变动的连锁反应而不知所踪。
通常我们处理子组件修改父组件值的需求，是通过给子组件传一个回调函数的形式，当子组件中的状态发生改变，需要通知父组件的时候，就调用该回调函数，然后由父组件改变后再通过 props 传回

```js
// <!-- 子组件 -->
import React from "react";

export default function Child(props) {
    const { value, valueChange } = props;
    return (
        <>
            <div> 接收父组件的值: {value} </div>
            <button onClick={() => valueChange("Changed Msg")}>
                修改父组件的值
            </button>
        </>
    );
}
```

### Context

`React Context`适用于父子组件以及隔代组件通信，`React Context`提供了一个无需为每层组件手动添加 props 就能在组件树间进行数据传递的方法。在 React 应用中数据是通过 props 属性自上而下即由父及子进行传递的，但这种做法对于某些类型的属性而言是极其繁琐的，这些属性是应用程序中许多组件都需要的，或者是需要跨组件传递的，而 Context 提供了一种在组件之间共享此类值的方式，而不必显式地通过组件树的逐层传递 props，实际上 React-Router 就是使用这种方式传递数据，这也解释了为什么`<Router>`要在所有`<Route>`的外面。react-router 共享了 history 的信息，从而实现数据共享。
使用 Context 是为了共享那些对于一个组件树而言是全局的数据，简单来说就是在父组件中通过 Provider 来提供数据，然后在子组件中通过 Consumer 来取得 Provider 定义的数据，不论子组件有多深，只要使用了 Provider 那么就可以取得在 Provider 中提供的数据，而不是局限于只能从当前父组件的 props 属性来获取数据，只要在父组件内定义的 Provider 数据，子组件都可以调用。当然如果只是想避免层层传递 props 且传递的层数不多的情况下，可以考虑将 props 进行一个浅拷贝之后将之后组件中不再使用的 props 删除后利用 Spread 操作符即{...handledProps}将其展开进行传递，实现类似于 Vue 的$attrs与$listeners 的 API 操作。

```js
// <!-- createNameContext.js -->

import React from "react";

const createNameContext = (name, defaultValue) => {
    let context = React.createContext(defaultValue);
    context.displayName = name;
    return context;
};

export default createNameContext;
```

```js
// <!-- Router.js -->

import React, { useState, useEffect, useRef } from "react";
import RouterContext from "./RouterContext";
import HistoryContext from "./HistoryContext";
function computeRootMatch(pathname) {
    return { path: "/", url: "/", params: {}, isExact: pathname === "/" };
}
function Router(props) {
    const {
        children,
        history,
        staticContext = false, // 是否是服务端渲染的标志
    } = props;
    const [location, setLocation] = useState(history.location); // location

    useEffect(() => {
        setLocation(history.location);
        let unListen = null;
        // 不是服务端渲染的情况下才
        if (!staticContext) {
            unListen = history.listen(({ action, location }) => {
                setLocation(location);
            });
        }

        return () => {
            if (unListen) {
                unListen();
            }
        };
    }, [history]);

    return (
        <RouterContext.Provider
            value={{
                history,
                location,
                match: computeRootMatch(location.pathname),
                staticContext,
            }}
        >
            <HistoryContext.Provider children={children} value={history} />
        </RouterContext.Provider>
    );
}

export default Router;
```

```js
// <!-- Route.js -->
import React from "react";
import RouterContext from "./RouterContext";
import { matchPath } from "./match";

// 判断是否是空的子列表
function isEmptyChildren(children) {
    return React.Children.count(children) === 0;
}

function Route(props) {
    const { path, component, children, render, computedMatch } = props;
    return (
        <RouterContext.Consumer>
            {(context) => {
                const { history, location, match } = context;
                const nowLocation = props.location || location;
                // nowMatch 是根据 path 生成的正则表达是匹配的，computedMatch 是用在Switch中的，这个时候已经匹配过了，所以就不需要再走matchPath的逻辑了
                const nowMatch = computedMatch
                    ? computedMatch
                    : path
                    ? matchPath(nowLocation.pathname, props)
                    : match;
                const newProps = { ...context, nowLocation, nowMatch };

                if (Array.isArray(children) && isEmptyChildren(children)) {
                    children = null;
                }
                /**
		 * 判断逻辑
		 * 1、判断 nowMatch 是否存在
		 * 2、nowMatch 存在 则 判断 children 是否存在
		 * 		2.1、children 存在 判断 children 是否是 function
		 * 			2.1.1、是function 则 children(newProps)
		 * 			2.1.2、不是 function 则 children
		 *		2.2、children 不存在 判断 component 是否存在
					 2.2.1、component 存在 则 React.createElement(component, newProps)
					 2.2.2、component 不存在 则 判断 render 是否存在
						 2.2.2.1、 render 存在 则 render(newProps)
						 2.2.2.2、 render 不存在 则 null
		 * 3、nowMatch 不存在 判断 children 是否是 function
		 		3.1、是function 则 children(newProps)
				3.2、不是 function 则 children
		 */
                return (
                    <RouterContext.Provider value={newProps}>
                        {nowMatch
                            ? children
                                ? typeof children === "function"
                                    ? children(newProps)
                                    : children
                                : component
                                ? React.createElement(component, newProps)
                                : render
                                ? render(newProps)
                                : null
                            : typeof children === "function"
                            ? children(newProps)
                            : children}
                    </RouterContext.Provider>
                );
            }}
        </RouterContext.Consumer>
    );
}

export default Route;
```

### Refs

`Refs`适用于父子组件的通信，`Refs`提供了一种方式，允许我们访问 DOM 节点或在 render 方法中创建的 React 元素，在典型的 React 数据流中，props 是父组件与子组件交互的唯一方式，要修改一个子组件，你需要使用新的 props 来重新渲染它，但是在某些情况下，需要在典型数据流之外强制修改子组件，被修改的子组件可能是一个 React 组件的实例，也可能是一个 DOM 元素，渲染组件时返回的是组件实例，而渲染 DOM 元素时返回是具体的 DOM 节点，React 提供的这个 ref 属性，表示为对组件真正实例的引用，其实就是 ReactDOM.render()返回的组件实例。此外需要注意避免使用 refs 来做任何可以通过声明式实现来完成的事情，通常在可以使用 props 与 state 的情况下勿依赖 refs

```js
// <!-- 子组件 -->
import React, { useState, useEffect, useImperativeHandle } from "react";

function Child(props, ref) {
    const { value, valueChange } = props;

    const getData = () => {
        console.log("child get data ");
    };

    useImperativeHandle(ref, () => {
        return {
            getData,
        };
    });
    return (
        <>
            <div> 接收父组件的值: {value} </div>
            <button onClick={() => valueChange("Changed Msg")}>
                修改父组件的值
            </button>
        </>
    );
}
React.forwardRef(Child);
```

```js
// <!-- 父组件 -->
import React, { useState, useEffect, useRef } from "react";

export default function father(props) {
    const childRef = useRef(null);

    useEffect(() => {
        console.log(childRef.current);
        if (childRef.current) {
            childRef.current.getData();
        }
    }, []);

    return <Child ref={childRef}></Child>;
}
```

### EventBus

`EventBus`可以适用于任何情况的组件通信，在项目规模不大的情况下，完全可以使用中央事件总线`EventBus` 的方式，`EventBus`可以比较完美地解决包括父子组件、兄弟组件、隔代组件之间通信，实际上就是一个观察者模式，观察者模式建立了一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应。所以发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展。注意在组件销毁的时候卸载订阅的事件调用，否则会造成内存泄漏。

```js
/**
 * 观察者模式
 */
import { observerType } from "./const/config";

/**
 * 容器
 * 容器中的格式应该是type确定类型，然后对应path，然后path对应的数组
 * 示例：
 * {
 *      type:{
 *        path:[]
 *      }
 * }
 */

export default function () {
    let message = {};
    Object.keys(observerType).forEach((key) => {
        if (observerType[key] === observerType.componentStateChange) {
            message[observerType[key]] = [];
        } else {
            message[observerType[key]] = {};
        }
    });
    /**
     * 订阅
     * @param {*} type
     * @param {*} config
     * config 格式示例
     * {
     *    path:'',
     *    callback:()=>{}
     * }
     */

    const subscribe = (type, config) => {
        const messageObj = message[type];
        if (type === observerType.componentStateChange) {
            messageObj.push(config.callback);
            return;
        }
        if (typeof messageObj[config.path] === "undefined") {
            messageObj[config.path] = [].concat(config.callback);
        } else {
            messageObj[config.path].push(config.callback);
        }
    };
    /**
     * 销毁
     * @param {*} type
     * @param {*} config
     */
    const destroy = (type, config) => {
        const messageObj = message[type];
        if (messageObj[config.path] instanceof Array) {
            const len = messageObj[config.path].length;
            for (let i = 0; i < len; i++) {
                if (messageObj[config.path][i] === config.callback) {
                    messageObj[config.path].splic(i, 1);
                    break;
                }
            }
        }
    };
    /**
     * 发布
     * @param {*} type
     * @param {*} arg
     * arg 结构示例
     * {
     *    path:'',
     *    value:any
     * }
     */

    const publish = (type, arg) => {
        const messageObj = message[type];
        if (type === observerType.componentStateChange) {
            const event = {
                type,
                ...arg,
            };
            const len = messageObj.length;
            for (let i = 0; i < len; i++) {
                messageObj[i].call(this, event);
            }
            return;
        }
        if (!messageObj[arg.path]) {
            return;
        }
        const event = {
            type,
            ...arg,
        };
        const len = messageObj[arg.path].length;
        for (let i = 0; i < len; i++) {
            messageObj[arg.path][i].call(this, event);
        }
    };

    const getMessage = () => {
        return message;
    };
    return {
        subscribe,
        publish,
        destroy,
        getMessage,
    };
}
```

```js
import React, { useState, useEffect } from "react";
import { observerType } from "./const/config";
import { isFunction, isObject, isArray } from "./utils/index";

// 默认的错误提示
const defaultErrorMessage = {
    isError: false, // 是否错误
    message: undefined, // 错误提示信息
};
/**
 * 成员装饰器
 * 表单对象的装饰器,主要是包装一层，将组建对外展示为非受控的模式，在内部实际上是受控的模式
 * @param {*} Component react 组建
 * @param {object} state 组建的路径，或者说是值在form表单中的位置
 */
export function itemDecorator(Component, state, observer) {
    if (!Component) return null;
    return function (props) {
        const [value, setValue] = useState(() => {
            if (state && typeof state.defaultValue !== "undefined") {
                return state.defaultValue;
            }
            return undefined;
        }); // 值
        const [errorMessage, setErrorMessage] = useState(defaultErrorMessage); // 是否错误
        const [componentsPropsState, setComponentsPropsState] = useState(() => {
            let result = {};
            if (
                state &&
                state["x-components-props"] &&
                isObject(state["x-components-props"])
            ) {
                const obj = state["x-components-props"];
                Object.keys(obj).map((key) => {
                    if (key !== "value" && key !== "onChange") {
                        if (isObject(obj[key])) {
                            result[key] = Object.assign({}, obj[key]);
                        } else if (isArray(obj[key])) {
                            result[key] = [].concat(obj[key]);
                        } else {
                            result[key] = obj[key];
                        }
                    }
                });
            }
            return result;
        }); // 被装饰组件传入的props中

        /**
         * 注册组件上所有on开头的事件
         */
        const registDomOnFunc = () => {
            const props = Object.assign({}, Component.props);
            const reg = /^on\s*/;
            Object.keys(props).forEach((key) => {
                if (reg.test(key)) {
                    observerType.subscribe(key, {
                        path: state.path,
                        callback: registDomCallback,
                    });
                    props[key] = (res) => {
                        props[key]();
                        observerType.publish(key, {
                            path: state.path,
                            value: res,
                        });
                    };
                }
            });
        };

        /**
         * on开头事件注册回调
         */
        const registDomCallback = (data) => {};

        /**
         * 修改componentsProps的方法
         * @param {*} data
         */
        const componentsPropsStateChange = (data) => {
            const result = Object.assign({}, componentsPropsState, data);
            setComponentsPropsState(result);
        };
        /**
         * 重置数值
         */
        const resetValue = (data) => {
            setValue(data);
        };

        /**
         * 校验错误
         */
        const validateDataError = (data) => {
            setErrorMessage(data);
        };

        // 数据修改
        const valueChange = (e) => {
            let value = undefined;
            if (e === undefined || e === null) {
                value = e;
            } else {
                value = e.target
                    ? e.target.value !== undefined
                        ? e.target.value
                        : undefined
                    : e;
            }
            setValue(value);
            // 发布更改
            observer.publish(observerType.valueChange, {
                path: state.path,
                value,
                props: componentsPropsState,
                index: state.arrayIndex,
            });
        };

        useEffect(() => {
            // 注册重置点击时的订阅
            observer.subscribe(observerType.reset, {
                path: state.path,
                callback: resetValue,
            });
            // 校验失败时触发
            observer.subscribe(observerType.validateDataError, {
                path: state.path,
                callback: validateDataError,
            });
            // 注册修改参数的订阅
            observer.subscribe(observerType.componentPropsChange, {
                path: state.path,
                callback: componentsPropsStateChange,
            });
            // 注册组件上on事件的订阅
            registDomOnFunc();
        }, []);
        return (
            <div className="universal-form-item">
                <Component
                    {...componentsPropsState}
                    value={value}
                    onChange={valueChange}
                />
                {errorMessage.isError && (
                    <div className="universal-form-error">
                        {errorMessage.message}
                    </div>
                )}
            </div>
        );
    };
}

/**
 * 容器装饰器
 * 表单的装饰器
 * @param {*} Component
 */
export function containerDecorator(Component, type) {
    const ContainerComponents = (props, ref) => {
        const [formParams, setFormParams] = useState(() => {
            if (type && type.toLowerCase() === "array") {
                return [];
            }
            return {};
        }); // 表单对象
        const [rulesData, setRulesData] = useState({}); // 校验规则

        /**
         * formParams修改
         * data 应该包含了两个参数，一个是path，一个是
         */
        const formParamsChange = (data) => {
            if (type && type.toLowerCase() === "array") {
            }
        };

        useEffect(() => {
            // observer.regist(observerType.reset, {
            //   path: '',
            //   func: formParamsChange,
            // });
        }, []);

        return <Component />;
    };
    return React.forwardRef(ContainerComponents);
}
```

### Redux(Recoil)

`Redux` 或者 `Recoil` 同样可以适用于任何情况的组件通信，`Redux`中提出了单一数据源`Store`用来存储状态数据，所有的组件都可以通过`Action`修改`Store`，也可以从`Store`中获取最新状态，使用了`redux`就可以解决多个组件的共享状态管理以及组件之间的通信问题
`Recoil` 在使用体验上更加舒服，基本的操作方式类似`useState`，只不过是统一管理的，并且可扩展性也比较强，但是需要注意`Recoil` 的使用会和`Suspense`起连锁反应

